#### [1605. 给定行和列的和求可行矩阵](https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/)

难度中等82

给你两个非负整数数组 `rowSum` 和 `colSum` ，其中 `rowSum[i]` 是二维矩阵中第 `i` 行元素的和， `colSum[j]` 是第 `j` 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。

请找到大小为 `rowSum.length x colSum.length` 的任意 **非负整数** 矩阵，且该矩阵满足 `rowSum` 和 `colSum` 的要求。

请你返回任意一个满足题目要求的二维矩阵，题目保证存在 **至少一个** 可行矩阵。

 

**示例 1：**

```
输入：rowSum = [3,8], colSum = [4,7]
输出：[[3,0],
      [1,7]]
解释：
第 0 行：3 + 0 = 3 == rowSum[0]
第 1 行：1 + 7 = 8 == rowSum[1]
第 0 列：3 + 1 = 4 == colSum[0]
第 1 列：0 + 7 = 7 == colSum[1]
行和列的和都满足题目要求，且所有矩阵元素都是非负的。
另一个可行的矩阵为：[[1,2],
                  [3,5]]
```

**示例 2：**

```
输入：rowSum = [5,7,10], colSum = [8,6,8]
输出：[[0,5,0],
      [6,1,0],
      [2,0,8]]
```

**示例 3：**

```
输入：rowSum = [14,9], colSum = [6,9,8]
输出：[[0,9,5],
      [6,0,3]]
```

**示例 4：**

```
输入：rowSum = [1,0], colSum = [1]
输出：[[1],
      [0]]
```

**示例 5：**

```
输入：rowSum = [0], colSum = [0]
输出：[[0]]
```

 

**提示：**

- `1 <= rowSum.length, colSum.length <= 500`
- `0 <= rowSum[i], colSum[i] <= 108`
- `sum(rowSum) == sum(colSum)`





```cpp
// 贪心算法
	// 在满足约束条件的情况下尽可能地去压榨剩余空间
	// 为什么不会导致后续的发展中,产生崩坏?
class Solution {
public:
    // 你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。
    vector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {
        // 数独？
        int n = rowSum.size(), m = colSum.size();
        vector<vector<int>> matrix(n, vector<int>(m, 0));
        int i = 0, j = 0;
        while (i < n && j < m) {
            int v = min(rowSum[i], colSum[j]);
            matrix[i][j] = v;
            rowSum[i] -= v;
            colSum[j] -= v;
            if (rowSum[i] == 0) {
                ++i;
            }
            if (colSum[j] == 0) {
                ++j;
            }
        }
        return matrix;
    }
};


```



















#### [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

难度简单682

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

 

**提示：**

- `1 <= g.length <= 3 * 104`
- `0 <= s.length <= 3 * 104`
- `1 <= g[i], s[j] <= 231 - 1`

> ## 我的思考
>
> ```cpp
> class Solution {
> public:
>     int findContentChildren(vector<int>& g, vector<int>& s) {
>         // 对于每个g,挑选满足其要求的最小的s
>         vector<bool> used (s.size(), false);
>         sort(g.begin(), g.end());
>         sort(s.begin(), s.end());
>         int i = 0;
>         int count = 0;
>         for(auto gg : g){
>             for(; i <s.size(); i++){
>                 if(s[i] >= gg && !used[i]){
>                     used[i] = true;
>                     count++;
>                     break;
>                 }
>             }
>         }
>         return count;
>         
>     }
> };
> ```





























































#### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

难度中等897

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

 

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例 2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例 3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`



> ## 我的思路
>
> 有点想用动态规划
>
> - dp[i] 范围内的最长摆动序列长度, 0-作为山谷, 1-作为山峰
> - 遍历之前所有元素 
>   - `dp[i][0] = max(dp[i][0], dp[j][1] + 1)` 
>   - `dp[i][1] = max(dp[i][1], dp[j][0] + 1)`
>
> ```cpp
> // 动态规划
> class Solution {
> public:
>     int dp[1005][2];
>     int wiggleMaxLength(vector<int>& nums) {
>         memset(dp, 0, sizeof dp);
>         dp[0][0] = dp[0][1] = 1;
>         for (int i = 1; i < nums.size(); ++i) {
>             dp[i][0] = dp[i][1] = 1;
>             for (int j = 0; j < i; ++j) {
>                 if (nums[j] > nums[i]) dp[i][1] = max(dp[i][1], dp[j][0] + 1);
>                 if (nums[j] < nums[i]) dp[i][0] = max(dp[i][0], dp[j][1] + 1);
>             }
>         }
>         return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);
>     }
> };
> ```
>
> 
>
> 贪心：
>
> 一段单调范围内的节点序列,只将首尾节点纳入序列
>
> <img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/image-20230330094731433.png" alt="image-20230330094731433" style="zoom: 67%;" />
>
> ```cpp
> class Solution {
> public:
>     int wiggle(bool flag, vector<int>& nums){
>         int curr_node = nums[0];
>         int count = 1;
>         for(int i = 1; i < nums.size(); i++){
>             if(flag == true){
>                 if(nums[i] > curr_node){ // 上升
>                     curr_node = nums[i];
>                     flag = false; // 下降
>                     count ++;
>                 }else{
>                     curr_node = nums[i];
>                 }
>             }
>             else if(flag == false){
>                 if(nums[i] < curr_node){
>                     curr_node = nums[i];
>                     flag = true;
>                     count ++;
>                 }else{
>                     curr_node = nums[i];
>                 }
>             }
>         }
>         return count;
>     }
>     int wiggleMaxLength(vector<int>& nums) {
>         int len1 = wiggle(true, nums);
>         int len2 = wiggle(false, nums);
>         return max(len1, len2);
>     }
> 
> };
> ```
>















#### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

难度中等2059

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

 

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`



> ## 我的思考
>
> 感觉有点类似于之前那个山峰山谷的问题,只不过只需要将所有山峰都叠加起来?
>
> ## Solution
>
> 最终利润是可以分解的
>
> 假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。
>
> 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。
>
> 将利润分摊到每天,而不是一个时间段的两个端点
>
> 相当于只收集山峰山谷中的上升的坡
>
> ```cpp
> // 比动态规划用的方法简单直观一些
> class Solution { 
> public:
> int maxProfit(vector<int>& prices) { int result = 0;
>     for (int i = 1; i < prices.size(); i++) { 
>         result += max(prices[i] - prices[i - 1], 0);
>     } return result;
> } 
> };
> 
> ```
>
> 

















#### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

难度中等2272

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 3 * 104`
- `0 <= nums[i] <= 105`



> ## 我的思考
>
> 文章中说的是, 所站的下标是下一步能够迈出的最大距离
>
> 下一步的位置 = 下一步 + 该位置的nums





```cpp
// 超时了,也不知道对不对
class Solution {
public:
    int nextStep(int curr, vector<int> & nums){
        int step = nums[curr];
        int nextPos = curr;
        int nextIdx = curr;
        for(int i = curr+1; i < curr + step; i++){
            if(nextIdx < i + nums[i]){
                nextIdx = i + nums[i];
                nextPos = i;
            }
        }
        return nextPos;
    }
    bool canJump(vector<int>& nums) {
        // 这里的下标是跳跃的最大长度
        int position = 0;
        while(position < nums.size()){
            int next = nextStep(position, nums);
            if(next == position) return false;
        }
        return true;
        
    }
};
```





> ## Solution
>
> 每次跳几步无所谓,重要的是能过跳跃的范围
>
> **贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。
>
> ```cpp
> class Solution {
> public:
>     bool canJump(vector<int>& nums) {
>         int cover = 0;
>         if (nums.size() == 1) return true; // 只有一个元素，就是能达到
>         for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
>             cover = max(i + nums[i], cover);
>             if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
>         }
>         return false;
>     }
> };
> // 我感觉跟我写的逻辑一样,但不知道为什么我的超时了
> // 逻辑不一样的地方在于for循环与跳出条件
> 	// 如果 i > cover的话, 则跳出并返回false? 为什么?
> 	// 相当于当i向前递进时,cover迭代之后还停留在原地,就会被i超过
> ```
>
> 

























#### [134. 加油站](https://leetcode.cn/problems/gas-station/)

难度中等1197

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

 

**示例 1:**

```
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

**示例 2:**

```
输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

 

**提示:**

- `gas.length == n`
- `cost.length == n`
- `1 <= n <= 105`
- `0 <= gas[i], cost[i] <= 104`



> ## 我的思考
>
> 如果当前减去cost之后, 油箱不足, 说明需要更换start, 直到start = curr时,即可返回, 否则通过记录的failcount来判断是否需要退出循环
>
> ```cpp
> class Solution {
> public:
>     int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
>         // 如果我们到达一个地方 i, 我们身上有 num 个汽油
>         // 那么此时对比的情况,就是我们从这里出发, 身上有 gas[i]的汽油
>         // 如果 num > gas[i] 那么肯定不能从这里出发,
>         // 如果 num < gas[i] 那么应该重新设置出发点
> 
>         int start = 0;
>         int num = gas[0];
>         int failcount = 0;
>         int curr = 0;
>         while(failcount != gas.size()){
>             num -= cost[curr];
>             curr = (curr +1) % gas.size();
>             // num 小于 0, 重置
>             if(num < 0){
>                 failcount ++;
>                 start = curr;
>                 num = gas[curr];
>             }else{
>                 if(curr== start){
>                     break;
>                 }
>                 num += gas[curr];   
>             }
>         }
>         if(failcount == gas.size()) return -1;
>         return start;
>     }
> };
> ```
>
> 这种方法是时间超时的
>
> 有一个比较重要的点就是, 1.题目保证了如果有解,则仅有一解 2.判断gasSum和costSum很有必要
>
> 会不会存在, gasSum 大于 costSum 但是无解的情况?
>
> 反证: 如果不存在,那么这个环一定是被一圈又一圈的橙色段所覆盖(只要是橙色即意味着不能从这里开始,如果不存在解的话,那么即使有一段不是橙色,也会后续的增长中变为橙色)
>
> [「图解」为什么总加油>=总油耗就一定有解？简单论证两个关键结论 | 附暴力法 - 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/solution/shou-hua-tu-jie-liang-ge-guan-jian-jie-lun-de-jian/)
>
> ![image-20230401111729266](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/image-20230401111729266.png)
>
> #### 我的证明
>
> 1. 如果一个环上只有 正负两段, 那么其大小一定相等
> 2. 如果环上不止这两段,而是有正负交替出现的多段(这里的段为 remain[i] = gas[i] - cost[i])
>    1. 将正正, 负负合并, 那么环中就会出现 正负交替出现,且数量相等
>    2. 此时按先正后负的pair将正负进行结对, 如果结果为正则为正, 结果为负则为负
>       1. 这里为正即意味着可以从这一段的起点为start
>    3. 此时再按1.中,正正负负进行合并,然后再按2中进行结对
>    4. 最后,即会出现只有正负两段的情况

































#### [135. 分发糖果](https://leetcode.cn/problems/candy/)

难度困难1154

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

 

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

 

**提示：**

- `n == ratings.length`
- `1 <= n <= 2 * 104`
- `0 <= ratings[i] <= 2 * 104`





> ## 我的思考
>
> 1. 相同孩子,可以有高低
> 2. 不同孩子,必须有高低,不能相等
> 3. 不是环状的, 数组首尾两人不进行比较
>
> 对每一段之间的上升下降进行记录,如果相等默认为下降,因为可以省,所以这里的记录应该是 size()-1条记录
>
> ```cpp
> class Solution {
> public:
>     int candy(vector<int>& ratings) {
>         vector<int>compareLog(ratings.size(), 0);
>         int minum = 0;
>         for(int i = 1; i <ratings.size(); i++){
>             if(ratings[i] > ratings[i-1]) compareLog[i] = compareLog[i-1]+1; // 上升
>             else{
>                 compareLog[i] = compareLog[i-1]-1; //下降
>                 minum = min(compareLog[i],minum);
>             } 
>         }
>         int sum = 0;
>         for(auto it:compareLog){
>             sum += it;
>         }
>         sum += ratings.size() * (1-minum);
>         return sum;
>     }
> };
> // 这里有一个逻辑错误, 即相等的孩子之间究竟是否有差距?
> // 如果产生差距会造成新的min, 那就不要有差距
> // 需要判断此时的log是否会产生新的谷底, 但是可能不会直接造成,而是间接造成谷底,
> ```
>
> ## Solution
>
> 局部最优：只要右边评分比左边大，右边的孩子就多一个糖果
>
> 全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果
>
> 这里进行了两次遍历, 相当于从左到右的增序片段,和从右到左的增序片段
>
> ```cpp
> class Solution {
> public:
>     int candy(vector<int>& ratings) {
>         vector<int> candyVec(ratings.size(), 1);
>         // 从前向后
>         for (int i = 1; i < ratings.size(); i++) {
>             if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
>         }
>         // 从后向前
>         for (int i = ratings.size() - 2; i >= 0; i--) {
>             if (ratings[i] > ratings[i + 1] ) {
>                 candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
>             }
>         }
>         // 统计结果
>         int result = 0;
>         for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
>         return result;
>     }
> };
> ```
>
> 我的理解是,将ratings进行解析, 转型成为我的candys
>
> - ratings存在山峰和山谷, 所有的山谷都应为1,然后山峰根据从山谷到山峰的steps数决定, 山峰两侧会有两个山谷,从两个山谷延伸来会有两个山峰高度,取max以同时满足两个山谷的要求
> - 有了这个基本逻辑之后,再来理解这段代码
> - 每一个山谷的高度都是1,当我们从左向右进行遍历时,我们构建了山峰的左侧,当我们从右向左进行遍历时,我们构建了山峰的右侧
> - 为什么是基于左侧的基础上再来构建右侧,右侧这个过程相当于是将山峰隆起, 我们需要有一个对山峰取max的过程,但这个max的来源,并不仅仅取决于山峰左右一步的距离,而是需要从山峰向左右走到底才行,如果仅仅关注在山峰左右的局部,那么就会像我的代码里面一样,会有山谷沉到地下,但这样就不满足, 山谷皆为1的原则要求,使得结果并不是最优































#### [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

难度简单432

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

 

**示例 1：**

```
输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```

**示例 2：**

```
输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
```

 

**提示：**

- `1 <= bills.length <= 105`
- `bills[i]` 不是 `5` 就是 `10` 或是 `20` 



```cpp
// 各种
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        vector<int> cash(3,0);// 5 10 20
        for(auto it : bills){
            switch(it)
            {
                case 5: cash[0]++; break;
                case 10: {
                    if(cash[0]>0){
                        cash[0]--;
                        cash[1]++;
                    }else{
                        return false;
                    }
                    break;
                }
                case 20: {
                    if(cash[0]>0&& cash[1]>0){
                        cash[2]++;
                        cash[0]--;
                        cash[1]--;
                    }else if(cash[0] >= 3){
                        cash[0] -= 3;
                    }
                    else{
                        return false;
                    }
                    break;
                }
            }
        }
        return true;
    }
};
```





































