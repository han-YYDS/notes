[代码随想录 (programmercarl.com)](https://www.programmercarl.com/)



**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组



**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。













#### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

难度简单545

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

 

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```





> 思路:
>
> dp数组: int a[2]
>
> a[0] + a[1] → a[0]
>
> a[0] + a[1] → a[1]
>
> 1. 在函数中怎么建立一个 持久的数组?
>    1. 不递归,所以不需要考虑这个
> 2. 对于 F(n)中的递推,如何实现奇偶的不同?
>    1. j=i%2, 以n为 for循环的次数,然后由i%2判断奇偶



> 动态规划五部曲:
>
> 1. 确定dp数组（dp table）以及下标的含义
>
>    1. a[n]即为第n个数
>
> 2. 确定递推公式
>
>    1. F(n) = F(n - 1) + F(n - 2)
>
> 3. dp数组如何初始化
>
>    1. ```text
>       dp[0] = 0;
>       dp[1] = 1;
>       ```
>
> 4. 确定遍历顺序
>
>    1. 由底向上
>
> 5. 举例推导dp数组
>
>    1. 0 1 1 2 3 5 8 13 21 34 55



```cpp
// My solution
class Solution {
public:
    //  F(n) = F(n-1) + F(n-2)
    int fib(int n) {
        // dp数组 - 2个
        if(n == 0)  return 0;
        if(n == 1)  return 1;

        int a[2] = {0,1};
        int j = 0;
        for(int i=1; i<=n; i++)
        {
            j = i % 2; 
            a[j] = a[0]+a[1];
        }
        return a[j];
    }
};
```



#### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

难度简单2718

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

1. 确定dp数组（dp table）以及下标的含义
   1. dp[n]即为n阶时的方法
2. 确定递推公式
   1. dp[n] = dp[n-1] +dp[n-2] // 我是 跨一步上来 还是 跨两步上来的
3. dp数组如何初始化
   1. dp[1] = 1, dp[2] = 2
4. 确定遍历顺序
   1. 由底向上
5. 举例推导dp数组
   1. n不等于0, {1,2,3,5,8}



```cpp
// My solution
class Solution {
public:
    int climbStairs(int n) {
        n = n-1;
        // dp数组 - 2个
        if(n == 0)  return 1;
        if(n == 1)  return 2;

        int a[2] = {1,2};
        int j = 0;
        for(int i=2; i<=n; i++) // 为什么这里的 i初始值要变? - 相当于改变数列的初始项
        {
            j = i % 2;
            a[j] = a[0]+a[1];
        }
        return a[j];
    }
};

```

















#### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

难度简单1041

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

**示例 1：**

```
输入：cost = [10,15,20]
	F(0) = 0
	F(1) = 0
	F(2) = (F(0)+cost(0)=10 , F(1)+cost[1]=15) = 10
	F(3) = (F(1)+cost(0)=15 , F(2)+cost[2]=30) = 15
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
	F(0) = 0
	F(1) = 0
	F(2) = (F(0)+cost[0]=1 , F(1)+cost[1]=100) = 1
	F(3) = (F(1)+cost[1]=100 , F(2)+cost[2]=30) = 3
	可以看到这里是可以只用2个int数组的
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。

总花费为 6 。
```

 



> 我到目前这个台阶,可以是从一个台阶上来的,也可以是从从两个台阶上来的
>
> 所以这里的 状态转移方程是什么?
>
> 1. 确定dp数组（dp table）以及下标的含义
>    1. F(x) - 到达台阶x的最小代价
> 2. 确定递推公式
>    1. F(x) = min(F(x-1)+cost[x-1], F(x-2)+cost[x-2])
>       1. 这一步有点像递归里面,F(x-1)即之前步骤中的最优结果,交给之前那一步去选择
>       2. 自顶向下?,如何将这一步转换为自底向上呢?
>          1. min(F(x)+cost[x], F(x+1)+cost[x+1])
> 3. dp数组如何初始化
>    1. F()
> 4. 确定遍历顺序
> 5. 举例推导dp数组





```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dest = cost.size();
        if(dest < 2) return 0;
        int dp0 = cost[0];
        int dp1 = cost[1];
        for(int i = 2; i<dest; i++)
        {
            int dpi = min(dp0,dp1)+cost[i];
            dp0 = dp1;
            dp1 = dpi;
        }
        return min(dp0, dp1); 
    }
};

// 	题解比我好在哪里?
对于dp数组下标的含义:
	我的含义 dp[i]的含义是: 我从开始到站在第i个台阶上的cost (脚还在i上)
    答案的含义 dp[i]的含义是: 我从i迈出去之后的cost (脚在i+1 或是i+2上)
由此引发的 状态转移方程也发生了变化
        我的: min(F(x)+cost[x], F(x+1)+cost[x+1])
        答案的: dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
// 如何降低空间复杂度?
	答案的状态转移方程中,对于空间的重复利用,是轮转而不是像我之前那样的奇偶变换,
	可以推测的是,对于状态转移方程,你有多少个先前状态,你的数组就需要分配多大即可,然后每一轮进行轮转,或者是用标记表示循环队列

```















#### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

难度中等1596

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171712950.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`



> ### 思路
>
> 我在我目前位置上的路径总数 = 我在我右边位置的路径总数 + 我在我下面的路径总数
>
> 1. 确定dp数组（dp table）以及下标的含义
>    1. 二维数组(m*n),每一位的含义为当前位置的路径总数
> 2. 确定递推公式
>    1. dp(x,y) = dp(x+1,y)+dp(x,y+1) // 这里就将start设置为左下角,dest设置为右上角,只能向右向上移动
> 3. dp数组如何初始化
>    1. dp(m,y) = 1
>    2. dp(x,n) = 1
> 4. 确定遍历顺序
>    1. 可以想到,当矩阵中的一个点,右边和下边存在结果,那么这个点的结果就可以得到
>    2. 对于每行来说,从右向左进行
>    3. <img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171712214.png" alt="image-20221105115005277" style="zoom: 25%;" />
> 5. 举例推导dp数组

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // 建立二维数组
        vector<vector<int>> dp (m, vector<int>(n,0)); // 初始化 m*n的矩阵
        for(int i = 0; i<m; i++) dp[i][0] = 1;  // 第0列
        for(int j = 0; j<n; j++) dp[0][j] = 1;  // 第0行
        for(int x = 1; x<m; x++){
            for(int y = 1; y<n; y++)
            {
                dp[x][y] = dp[x-1][y] + dp[x][y-1];
            }
        }
        return dp[m-1][n-1];


        // 循环遍历
    }
};

```







#### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

难度中等905

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

 

**示例 1：**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171712697.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

**示例 2：**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171712571.jpg)

```
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
```

 

**提示：**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`



> ### 思路
>
> 延续上面的思路:
>
> ​	我在我目前位置上的路径总数 = 我在我右边位置的路径总数 + 我在我下面的路径总数
>
> ​	判断是否存在障碍,如果存在障碍,则该点置为 -1;
>
> 几个坑:
>
> ​	对于 dp [x] [y],如果要画图来具象化, 一维数组应当是 ↑↑↑ 这样排列, 否则会对不上
>
> ​	对于矩阵的两条边进行初始化,意味着交点会处理两次,这需要注意
>
> ​		而如果单纯地绕过了(0,0)这个点之后,当(0,0)=1时,也会产生错误,应该在最开始对(0,0)单独处理
>
> **something new**
>
> - 初始化一个二维数组



```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        // 遍历数组,对其进行初始化
            // 1. 对于边上的数组, 置为1
            // 2. 对于障碍数组,置为-1
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(obstacleGrid[0][0] == 1)
        {
            for(int x = 0; x<m; x++) obstacleGrid[x][0] = -1;
            for(int y = 0; y<n; y++) obstacleGrid[0][y] = -1;
        }
        for(int x = 0; x < m; x++)  // 第0行
        {
            if(obstacleGrid[x][0] == 0){
                obstacleGrid[x][0] = 1;
                continue;
            } 
            // 将障碍以及之后的全部取为-1
            for(int i = x; i < m; i++){
                obstacleGrid[i][0] = -1;
            }
            break;
        }
         
        for(int y = 1; y < n; y++)  // 第0行
        {
            if(obstacleGrid[0][y] == 0){
                obstacleGrid[0][y] = 1;
                continue;
            } 
            // 将障碍以及之后的全部取为-1
            for(int j = y; j < n; j++){
                obstacleGrid[0][j] = -1;
            }
            break;
        }

        for(int x = 1; x<m; x++){
            for(int y = 1; y<n; y++){
                if(obstacleGrid[x][y] == 1) obstacleGrid[x][y] = -1;
            }
        }

        // 循环遍历数组
        for(int x = 1; x<m; x++){
            for(int y = 1; y<n; y++)
            {
                int a = obstacleGrid[x-1][y];
                int b = obstacleGrid[x][y-1];
                // 两种情况, 等式左边是 -1, 或者等式右边是-1
                if(obstacleGrid[x][y] == -1)  continue;
                if(obstacleGrid[x-1][y] == -1) a=0;
                if(obstacleGrid[x][y-1] == -1) b=0;
                obstacleGrid[x][y] = a+b;
            }
        }
        if(obstacleGrid[m-1][n-1] == -1) return 0;
        return obstacleGrid[m-1][n-1];
        return obstacleGrid[0][0];
    }
};

// 答案和我的有什么不同
	// 答案重新开辟了一个二维数组 
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
	if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0
            return 0;
        vector<vector<int>> dp(m, vector<int>(n, 0)); // 在栈中创建一个二维数组的方法
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue; // 遇到障碍将其置为0即可
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};

```







#### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

难度中等969

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```  
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。 n=2应该需要单独处理?
n = 3 return 2
n = 4 return 4 
n = 5 return 6 
n = 6 return 9 (2*2*2 = 8) (3*3=9)
n = 7 return 12 (2*2*3 = 12)
n = 8 return 16 (4*4 = 16) (3*3*2 = 18)
n = 9 reutrn (4*5 = 2*2 * 3*2 = 20) (3*3*3 = 27)
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 
```

 

**提示:**

- `2 <= n <= 58`



> **思路**
>
> - 到最后,每一个数都分解为 2,3 的和.
> - 是不是.3越多越好
>   - %3=1, 意味着存在自一个 3+1 化成 2+2更好
>   - %3=2, 意味着此时更好,现在3最多

```cpp
// 这里采用的是 3拆分的数学方法, 是用贪心做的
class Solution {
public:
    int integerBreak(int n) {
        if(n == 2) return 1;
        if(n == 3) return 2;
        int j = n/3;
        int i = n%3;
        // 如果余1, 将3+1变成2+2
        if(i == 1) return pow(3,j-1)*4;
        if(i == 2) return pow(3,j)*2;
        return pow(3,j);
    }
};
```



```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) { // 
            for (int j = 1; j < i - 1; j++) { // 对所有因式进行遍历
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); // (i-j)*j i-j不再拆分和 dp[i-j]*j i-j继续拆分 
            }
        }
        return dp[n];
    }
};
// 为什么要取 max( i-j, dp(i-j))?
	// 因为 i-j = i-j + 0 这种拆分不能纳入到dp中去, 0作为因子会使乘积为0
// 为什么拆分时,只有i-j继续拆分,而没有对j继续拆分?
	// 因为在遍历时,会有j不可再分的情况,这种会包含对j拆分的情况
```















#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

难度中等1987

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 

**示例 1：**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171711112.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

 

**提示：**

- `1 <= n <= 19`



> #### 思路
>
> ###### 我的思路
>
> 针对于新加入的结点,情况分为三种
>
> - 插入原树,作为其叶子结点
> - 作为原树的根
> - 这一种情况就是比较不知道怎么办的情况, 插入到原树,但是作为了其子树的根



> ###### 答案的思路
>
> 由于是二叉搜索树,所以当根确定时,其左右子树的结点数目是确定的
>
> 比如在(1,2,3,4)结点组成的树中,当根节点是3时,左子树一定有2个结点,右子树一定有1个结点
>
> 
>
> dp[i] += dp[j - 1] * dp[i - j];
>
> dp[1] = dp[0] * dp[0] 
>
> dp[2] = dp[0] * dp[1] + dp[1] * dp[0]
>
> 
>
> 关键在于,不在乎左右子树中具体是哪些结点,重要的是根左右的子树的==node个数==,将问题分解为 左右node个数 的n种组合

```cpp
class Solution { 
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```



> 这个题的关键在于,树的形状确定之后,这个树中,每个点对应的数字是唯一的,
>
> ​	因为这个树的中序遍历结果唯一,所以在该树形上的结点顺序唯一
>



其实 二叉搜索树的数目 和之前的 整数拆分有异曲同工之处,都是需要将一个值分解为其他值的和,然后当前的dp[i]是该对分解的组合的一些处理结果,整数拆分中是max,而二叉搜索树中是∑









#### 背包问题

![image-20230115130050254](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171711401.png)





##### 01背包

有n件物品和一个最多能背==重量bagweight==为w 的背包。第i件物品的重量是==weight[i]==，得到的价值是==value[i]== 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和==最大==

- 背包容积: bagweight = w
- 货物重量: weight[]
- 货物价值: value[] 





##### 二维dp

[代码随想录 (programmercarl.com)](https://www.programmercarl.com/背包理论基础01背包-1.html#二维dp数组01背包)

<img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171711861.png" alt="image-20230115135848683" style="zoom: 50%;" />

**dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

 ==dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);==



如果我选择拿起第i件物品,那么我的价值总和 = i的价值 + 扣去了代价的dp



> ##### 第一行的内容是什么?
>
> ​	指的是在只有物品0时,在不同容积下的存储情况
>
> ##### 第一行在何时初始化?
>
> ​	对于二维数组, 第一行需要单独初始化, 也就是判断只有物品0时的装载情况
>
> ​	对于一维数组, 第一行初始化的过程在判断不能拿起物品后,`if (j < weight[i]) dp[j] = dp[j]`,便完成了初始化,之所以二维数组不可以完成,是因为`dp[i][j] = dp[i - 1][j]`中,当i=0时,i-1= -1
>
> 
>
> ##### 为什么要这么遍历?
>
> ​	为什么要从上到下?
>
> ​		因为物品的加入是从少到多的,从1->n的,只有知道规模为1的情况,才能向上递推到n
>
> ​		
>
> ​	我认为和动态规划的逻辑有关系, 我们在做动态规划时,求解元素数量为n的这么一个问题规模,我们所能知道的是,当元素数量是n-1时,怎么从 n-1 到 n, 即状态转移方程所描述的, `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]),` 但其实我们也不知道n-1的具体值,我们所做的是 继续从 n-1 到 n-2 然后一直到 元素数量只有1个时的情况
>
> ​	这种思路其实就是和递归类似,递归就是层层下潜,最后触底,终于得到一个基本的不可再分的,可以得到具体结果的解,然后再步步弹栈,得到元素为n时的解
>
> ​	而动态规划则类似于,我从触底的那个步骤再往上发展,我先去得到,当元素只有一个时这个问题的具体的解,然后通过递推,得到问题规模发展为两个元素之后的解的情况,
>
> ```cpp
> // weight数组的大小 就是物品个数
> for(int i = 1; i < weight.size(); i++) { // 遍历物品
>  for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
>      if (j < weight[i]) dp[i][j] = dp[i - 1][j];  // 1.不能拿起物品i的情况
>      else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); // 2.能拿起但不如不拿的情况 	2.能拿起而且拿起更好的情况
>  }
> }
> // 1. 当前这个物品的重量大于容积 - 直接跳过 - 不进行覆盖 dp[i][j] = dp[i - 1][j]
> // 2. 当其这个物品的重量小于容积
> 	// 2.1 能拿起但是不如不拿  dp[i - 1][j]
> 	// 2.2 能拿起而且拿起来更好  dp[i-1][j-value[j]]+value[j]
> ```
>
> 







##### 一维dp

<img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171711861.png" alt="image-20230115135848683" style="zoom: 50%;" />



> #### faltten
>
> ​	我的理解是,当我们去构造这个二维数组时,是由左上到右下建立起来的,当我们建立物品2这一行时,只有物品1这一行会被用到,而0其实已经没有用了,所以我们可以在内存中只申请一行的空间,然后对其进行迭代,覆盖前的内容为上一行,覆盖之后的内容为下一行
>
> ​	当我们是先遍历物品然后再遍历重量这种顺序时,要注意到,我们用 dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]来计算下一行时,所用到的都是上一行的数据,所以在覆盖时,要保证覆盖之后的数据不会再次参与到计算中,所以对于该行的计算要从右到左进行
>
> ##### 纵轴从上从上到下, 横轴上从右到左
>
> ​	在进行一维数组求解时,逻辑过程应该是先想二维情况,然后再将其faltten到一维,同时固定遍历顺序,从上到下,从右到左
>
> ##### 	为什么要从右到左?
>
> ​		在一维数组中,我们faltten了二维数组,  dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);, 根据状态转移方程,我们可以知道,我们求解dp[j]是需要dp[j-weight]的,并且此时的dp[j-weight]要保证是上一次i-1时的值,所以如果从左到右进行遍历,那么产生的改变会有叠加



```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量 - 从右到左
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
// note
	// 1- 初始化
		// dp数组长度为 w+1 因为0会空出来
		// 数组第一行的初始化不需要单独写,因为会在 判断当前物品是否大于容积时 j >= nums[i] 进行初始化
	// 2- 遍历顺序
		// 对于重量的遍历时从右到左的
```



















#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

难度中等1605

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`



> #### 思路
>
> 将一个数组分割成两个相等的子集, 如何将其和动态规划联系起来? 这里面怎样才会有子问题的嵌套情况出现?
>
> 首先将第一个元素作为第一组,其余元素作为第三组,问题变为, 如何将第三组分为 相差nums[1]大小的两个子集?
>
> 1. 然后将第2个元素纳入第一组,问题变为如何将第三组变为相差 gap=nums[1]+nums[2]大小的两个子集?
> 2. 将第2个元素纳入第二组,问题变为如何将第三组变为相差 gap=nums[1]-nums[2]大小的两个子集
>
> 如果最后第三组只剩一个元素,问题变为 此时这个元素的大小是否等于之前那个gap的绝对值
>
> 这是递归的情况,现在要将递归变为动态规划的策略,如何写出状态转移方程呢?
>
> 如果有一个二维数组的话,怎么样去套呢?
>
> 能不能和01背包所联系起来?
>
> 背包是怎么样拿能够到达最大
>
> 
>
> ==可以去计算数组的和sum,然后转化为 w=1/2 sum的01背包问题,去计算这种情况下最大的背包重量,将其和1/2 sum所比较是否相同==



```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 01背包问题 w = 1/2 sum ,value数组和weight数组相同
        int sum = 0;
        for (auto it:nums){
            sum += it;
        }
        if (sum % 2 == 1) return false;
        int w = 0.5 * sum;

        // 采用一维数组解决背包问题
        vector<int> dp (w+1, 0);
        // 1.对物品进行for循环
        for(int i = 0; i < nums.size(); i++){
            // 2.对容积进行遍历 这个要从右往左遍历
                // 三种情况
                    // 1. 当前这个物品的重量大于容积 - 直接跳过 - 不进行覆盖
                    // 2. 当其这个物品的重量小于容积
                        // 2.1 拥有该物品之后的背包存储 - dp[i-1][j-value[j]]+value[j]
                        // 2.2 没有拥有该物品之后的背包存储 - dp][i-1][j]
                // 对于压缩成一维数组之后 dp[j] = max(dp[j-value]+value, dp[j])
                // 对于第一组,要么满足第一种情况,要么不满足.
            for(int j = w; j >= nums[i]; j--){
                dp[j] = max(dp[j-nums[i]]+nums[i], dp[j]);
            }
        }
        if(dp[w] == w) return true;
        return false;
    }
};

// note
	// 1- 初始化
		// dp数组长度为 w+1 因为0会空出来
		// 数组第一行的初始化不需要单独写,因为会在 判断当前物品是否大于容积时 j >= nums[i] 进行初始化
	// 2- 遍历顺序
		// 对于重量的遍历时从右到左的
```















#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

难度中等597

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。



**示例 0：** 

```
输入：stones = [1,1,1,2]
sum = 5
w = 2
weight = 2
gap = sum -2w = 1

输入：stones = [1,1,3,2]
sum = 7
w = 3
weight = 3
gap = sum - 2w = 1

输入：stones = [1,1,5,2]
sum = 9
w = 4
weight = 4
gap = sum - 2w = 1
```

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

组合 2 和 7，得到 5，所以数组转化为 [5,4,1,8,1]，
组合 5 和 4，得到 1，所以数组转化为 [1,1,8,1]，
组合 1 和 1，得到 0，所以数组转化为 [8,1]，
组合 8 和 1，得到 7 这不是最优值

sum = 23
w = 11
weight = 11

```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`



> #### 思路
>
> 其实也是相当于将数组分为两个子集,满足两个子集sum的差值最小,和前面一题有类似之处,也是采用背包容积为1/2 sum的01背包,在此情况下求得的最大背包重量 weight, 返回的结果gap就是 sum-2weight
>
> ##### 01背包步骤:
>
> 1. 两个循环
>    1. 外循环遍历物品,内循环遍历重量,内循环从外到内,在第一次遍历时实现对第1行的初始化



```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (auto it : stones){
            sum += it;
        }
        // 如果sum为奇数,则w去一
        int w = 0.5 * sum;
        vector<int> dp = vector(w+1,0); 
        for(int i = 0; i < stones.size(); i++){
            for(int j = w; j >= stones[i]; j--){
                dp[j] = max(dp[j],dp[j-stones[i]] + stones[i]);
            }
        }
        return sum - 2*dp[w];
    }
};

// note
/*
	1-  j >= stones[i] 这里的等号是因为当等于该weight时是能够携带该货物的
	2- dp[j] = max(dp[j],dp[j-stones[i]] + stones[i]); 这里是取 原本的重量 和 携带该物品的重量 的max,而不是无条件的迭代
*/
```























#### [494. 目标和](https://leetcode.cn/problems/target-sum/)

难度中等1507

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

 

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`





> 思路:
>
> - 通过暴力求解的话,遍历 2^length 次,对所有组合进行遍历,对满足条件的情况进行count
>
> 考虑到动态规划 - 这个问题联系到背包问题 - 01背包问题是对货物数组进行挑选 - 这个问题是对货物数组中必须挑选,需要从1和-1中对其系数进行选择
>
> 递归:
>
> 将数组中的最后一个元素,加或者减到target上 -> 转化到动态规划
>
> dp[n] [target] = dp[n-1] [target + data[n]] + dp[n-1] [target - data[n]]



我的思路,将最终所需结果拆分, `dp[n] [target] = dp[n-1] [target + data[n]] + dp[n-1] [target - data[n]]`

用递归去写这个解决过程是简单直接的,但是如何运用动态规划并不知道,难点在于不知道该如何确定过程

```CPP
// 递归思路
class Solution {
public:
    int func(int n, int target, vector<int>& nums) {
        if (n == 1) {
            if (nums[0] == target && target==0) return 2;
            if (nums[0] == target || nums[0] == target*-1) return 1;
            return 0;
        }
        return func(n - 1, target + nums[n-1], nums) + func(n - 1, target - nums[n-1], nums);
    }

     int findTargetSumWays(vector<int>& nums, int target){
        return func(nums.size(), target, nums);
    }

};
```





###### 动态规划思路

> 对于数组中的元素进行分类,left和right两类(left前面的符号为正,right前面的符号为负,两者的绝对值的和为sum,产生的结果为left-right=target)
>
> target = left - right
>
> sum = left + right
>
> 可以通过target,sum来构造left, left = (target+sum)/2,
>
> 由于, sum和target都是给定的, 
>
>  ==所以问题转化为,在数组中挑选出子集,其和为(target+sum)/2==
>
> - bagweight = left
> - value[] = nums[]
> - weight[] = nums[] 
>
> ---
>
> 同时,我们之前所解决的背包问题为==在一定背包容积下的最大能装载货物重量==,而这里我们所解决的是在这些货物中,能够达到容积的组合数目
>
> 其实这题现在看来有点像[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/),只不过这个题是针对于,是否能够达到指定重量(1/2背包容积),而这题是要求达到指定重量的组合数目
>
> ##### 解决方法:
>
> - dp[j]: 填满容量volume为j的背包,共有dp[j]种方法
> - 如果从货物中拿出一个物品i,其重量为nums[i]
>   - 如果纳入背包, 则到达目标j,还需要 ==dp[j-nums[i]]==种方法
>   - 如果不纳入背包,则还需要==dp[j]==种方法
>   - question: 为什么纳入之后的方法是dp[j-nums[i]]呢? 会不会将物品nums[i]纳入两次呢?
>     - 注意,此时的纳入和不纳入是两个并行的方法,==即这两种的dp数组都是暗含了,nums[]中剔除了物品i之后去计算的下一步的方法数量==
>     - 相当于二维数组解法中的纵轴,遍历物品i这一过程,被简化了,被faltten了,所以其遍历过程没有显示的表达出来,其实放到二维中,`dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]`
> - 所以遍历过物品i之后, ==dp[j] += dp[j-nums[i]]==
>   - 
>   - ==组合类==的问题
>
> ```cpp
> // bagsize = target
> //  组合方式
> // 从上到下, 从右到左
> // 递归视角: 集合中拿掉最后一个物品 dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]
> // 动态规划视角: 集合中多了一个物品
> 
> // 1. 当前这个物品的重量大于容积 		dp[i][j] = dp[i - 1][j]
> // 2. 当其这个物品的重量小于容积 		dp
> ```
>
> 
>
> 

```cpp
// 动态规划思路
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(auto it: nums)
        {
            sum+=it; //对nums求和
        }
        // left + right = sum
        // left - right = target
        // left = 1/2 * (sum+target)
        // 问题转化为, 01背包问题: bagweight = left, value[] = nums[], weight[] = nums[]
        int volume = 0.5 * (sum+target);
        if(abs(target) > sum) return 0; // 预判断一下
        if((sum+target)%2 == 1) return 0; // 如果sum+target不能被2整除,说明不存在left,因为left是其和的1/2

        vector<int> dp (volume+1, 0);
        dp[0] = 1; // 当我的bagsize=0时,如果此时存在 j==nums[i], 即存在物品重量为0,则应是能有一次方法

        // 纵轴遍历 物品nums, 横轴遍历 重量 bagsize <- 0
        // 要faltten纵轴的话,for循环外层为纵轴
        // 纵轴从上到下, 横轴从右到左
        for(int i =0; i < nums.size(); i++){
            for(int j=volume; j>=nums[i]; j--){ // 如果 j<nums[i], 那么肯定不能拿进背包, dp[j]没有变化
                dp[j] += dp[j-nums[i]];
            }
        }
        return dp[volume];
    }
};
```







#### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

难度中等871

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

 

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`



> #### 思路
>
> 有点类似于 01背包重复两次, m和n就是两个bagsize,然后数组中的元素进行解析,得到其weight[], 比如"0101"对应的就是2,2
>
> 这里的value是1, weight是其01个数
>
> 但是相当于同时满足两个weight才能够获得一个value
>
> ==双重代价?==
>
> 逻辑上是外层循环遍历每一个物品,然后再对容量进行遍历? (m和n两个方向上的遍历? )
>
> 这里的逻辑为 三维数组`, dp[i][j][k] = max (dp[i-1][j-nums1[i]][k-nums0[i]] + 1, dp[i-1][j][k])`
>
> 以此为根据构建三维数组的遍历.





```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // 对strs进行解析, 得到 nums0[] 和 nums1[]
        vector<int> nums0(strs.size(), 0);
        vector<int> nums1(strs.size(), 0);
        int i = 0;
        for(auto s : strs)
        {
            for(auto c : s)
            {
                if(c == '1') nums1[i]++;
                if(c == '0') nums0[i]++;
            }
            i++;
        }
        vector<vector<int>> dp (m+1, vector<int>(n+1,0)); // m+1 和 n+1是因为存在背包容积为0的情况,这种也可以进行装载
        
        // 背包问题 双重代价?
        // 这里的逻辑为 三维数组, dp[i][j][k] = max (dp[i-1][j-nums1[i]][k-nums0[i]] + 1, dp[i-1][j][k])
        for(int j = 0; j < strs.size(); j++){
            // m nums0
            for(int k=m; k >= nums0[j]; k--){
                for(int l=n; l >= nums1[j]; l--){
                    dp[k][l] = max(dp[k-nums0[j]][l-nums1[j]]+1, dp[k][l]);
                }
            }
        }
        return dp[m][n];
    }
};
```





















#### 完全背包问题



**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**



​	背包重量为4

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |



> #### 我的思考
>
> ​	我认为可以从性价比入手, 物品0的性价比为15, 物品1的性价比为6.66, 物品2的性价比为7.5, 所以先装物品0,等到装不下了再去看物品2,接着再去看物品1.
>
> ​	但这样也存在一个问题, 可能在物品0接近装满时, 再拿出一个物品0,可以装入更多价值的其他物品

​	

> - ### resolution
>
>   - 01背包中,内循环即容量遍历,是从大到小的,也就是从右到左,是为了保证对于物品i产生的改变不会叠加
>
>   - 但是在完全背包中,由于物品的数量是无限,所以我们可以允许叠加,也需要叠加的产生,所以在完全背包中,内侧遍历的顺序是从左到右的 (还是有点无法理解)
>
>     - 当遍历到物品i时,首先容量遍历到j,此时进行判断,并做出改变,那么当后面遍历到k时, 如果 k-weight[i]=j, 则会用到已经改变过的dp[j],此时如果进行判断如果加入物品i更好,则继续叠加, 此时物品i已经叠加两次
>
>   - ##### 当物品从 i-1 遍历到 i时,是如何将背包中的 物品i-1拿出来, 给物品i腾地方的?
>
>     - ```cpp
>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
>       // 在这句代码中, dp[j - weight[i]],腾出位置后的背包重量
>       ```
>
> - #### 为什么遍历物品在外侧,遍历容量在内侧?
>
>   - 对于纯完全背包问题,即求解最大背包重量,内外侧遍历的顺序是可以改变的
>   - 但是对于,装满背包有多少种方式,两个for循环的顺序是需要斟酌的





























#### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

难度中等999

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回==可以凑成总金额的硬币组合数。==如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 



**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```

 

**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同 ** //之所以不同,是因为每个coin的数量为无穷
- `0 <= amount <= 5000`









> - ### 我的思考
>
>   - `dp[i][j]` : 当遍历到coins[i]时, bagsize=j时的 能够凑到amount的 组合数量
>   - 状态转移方程 : `dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]];`
>     - 首先,思考当我们位于 `dp[i-1][j]`时,此时纳入一个新的物品i, 原有的组合数量肯定不会改变, 我们需要考虑 用容积换取该物品之后的情况, 即 `dp[][j-coins[i]]`的情况, 但同时要考虑到,我们此时coins的数量无限,所以应当是 `dp[i][j-coins[i]`,
>
> 
>
> - ### my solution
>
>   ```cpp
>   class Solution {
>   public:
>       int change(int amount, vector<int>& coins) {
>           // 首先尝试一下,先遍历背包,再遍历物品
>           // 先写一次二维数组的
>           if(amount == 0) return 1;
>           if(coins.size() == 1){
>               if(amount % coins[0] == 0) return 1; // 能够整除 返回1
>               return 0; // 不能整除 返回0
>           }
>           vector<vector<int>> dp (coins.size(), vector<int>(amount+1, 0));
>           for(int i = 0; i < coins.size(); i++){
>               dp[i][0] = 1;
>           }
>           for(int i = 0; i <= amount; i++){
>               if(i % coins[0] == 0) dp[0][i] = 1; // 整除置为1
>               else dp[0][i] = 0; // 不能整除置为0
>           }
>           for(int i = 1; i < coins.size(); i++){ // 先遍历物品
>               for(int j = 0; j <= amount; j++){ // 再遍历背包
>                   if(j < coins[i]) dp[i][j] = dp[i-1][j];
>                   else{
>                       dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]];
>                   }
>               }
>           }
>           return dp[coins.size()-1][amount];
>       }
>   };
>   ```
>
>   



> ### 答案
>
> - ##### 动态规划
>
>   - dp[j] - 凑成总金额j的货币组合数量
>   - dp[j] += dp[j-coins[i]]  状态转移方程
>     - 未纳入前 + 纳入后减少质量
>   - 遍历顺序 假设 coins[0] = 1，coins[1] = 5
>     - 如果是先遍历物品,后遍历背包, 那么会先加入钱币1, 再加入钱币5, 得到的方法是{1,5}而不会有 {5,1}
>     - 而如果先遍历背包,再遍历物品, 那么此时会既有 {1,5} 也会有{5,1}
>   - 举例: amount = 5, coins = [1, 2, 5]
>     - <img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302251138669.png" alt="image-20230225113814491" style="zoom:50%;" />
>
> - ##### 为什么初始化的时候, dp[j] += dp[j - coins[i]], 不会导致递增吗?
>
>   - 因为原先的 dp[j]=0, 所以也相当于自动完成了初始化
>   - 而在后面的遍历中,这个操作相当于在原有基础上进行 2个1换 1个2的兑换过程, 并且要求从左向右进行,来保证叠加效果
>
> - ##### Solution
>
>   - 
>
>   - ```cpp
>     class Solution {
>     public:
>         int change(int amount, vector<int>& coins) {
>             vector<int> dp(amount + 1, 0);
>             dp[0] = 1;
>             for (int i = 0; i < coins.size(); i++) { // 遍历物品
>                 for (int j = coins[i]; j <= amount; j++) { // 遍历背包
>                     dp[j] += dp[j - coins[i]];
>                 }
>             }
>             return dp[amount];
>         }
>     };
>     ```
>
>   - 

