[代码随想录 (programmercarl.com)](https://www.programmercarl.com/)



**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组



**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。













#### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

难度简单545

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

 

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```





> 思路:
>
> dp数组: int a[2]
>
> a[0] + a[1] → a[0]
>
> a[0] + a[1] → a[1]
>
> 1. 在函数中怎么建立一个 持久的数组?
>    1. 不递归,所以不需要考虑这个
> 2. 对于 F(n)中的递推,如何实现奇偶的不同?
>    1. j=i%2, 以n为 for循环的次数,然后由i%2判断奇偶



> 动态规划五部曲:
>
> 1. 确定dp数组（dp table）以及下标的含义
>
>    1. a[n]即为第n个数
>
> 2. 确定递推公式
>
>    1. F(n) = F(n - 1) + F(n - 2)
>
> 3. dp数组如何初始化
>
>    1. ```text
>       dp[0] = 0;
>       dp[1] = 1;
>       ```
>
> 4. 确定遍历顺序
>
>    1. 由底向上
>
> 5. 举例推导dp数组
>
>    1. 0 1 1 2 3 5 8 13 21 34 55



```cpp
// My solution
class Solution {
public:
    //  F(n) = F(n-1) + F(n-2)
    int fib(int n) {
        // dp数组 - 2个
        if(n == 0)  return 0;
        if(n == 1)  return 1;

        int a[2] = {0,1};
        int j = 0;
        for(int i=1; i<=n; i++)
        {
            j = i % 2; 
            a[j] = a[0]+a[1];
        }
        return a[j];
    }
};
```



#### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

难度简单2718

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

1. 确定dp数组（dp table）以及下标的含义
   1. dp[n]即为n阶时的方法
2. 确定递推公式
   1. dp[n] = dp[n-1] +dp[n-2] // 我是 跨一步上来 还是 跨两步上来的
3. dp数组如何初始化
   1. dp[1] = 1, dp[2] = 2
4. 确定遍历顺序
   1. 由底向上
5. 举例推导dp数组
   1. n不等于0, {1,2,3,5,8}



```cpp
// My solution
class Solution {
public:
    int climbStairs(int n) {
        n = n-1;
        // dp数组 - 2个
        if(n == 0)  return 1;
        if(n == 1)  return 2;

        int a[2] = {1,2};
        int j = 0;
        for(int i=2; i<=n; i++) // 为什么这里的 i初始值要变? - 相当于改变数列的初始项
        {
            j = i % 2;
            a[j] = a[0]+a[1];
        }
        return a[j];
    }
};

```

















#### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

难度简单1041

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

**示例 1：**

```
输入：cost = [10,15,20]
	F(0) = 0
	F(1) = 0
	F(2) = (F(0)+cost(0)=10 , F(1)+cost[1]=15) = 10
	F(3) = (F(1)+cost(0)=15 , F(2)+cost[2]=30) = 15
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
	F(0) = 0
	F(1) = 0
	F(2) = (F(0)+cost[0]=1 , F(1)+cost[1]=100) = 1
	F(3) = (F(1)+cost[1]=100 , F(2)+cost[2]=30) = 3
	可以看到这里是可以只用2个int数组的
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。

总花费为 6 。
```

 



> 我到目前这个台阶,可以是从一个台阶上来的,也可以是从从两个台阶上来的
>
> 所以这里的 状态转移方程是什么?
>
> 1. 确定dp数组（dp table）以及下标的含义
>    1. F(x) - 到达台阶x的最小代价
> 2. 确定递推公式
>    1. F(x) = min(F(x-1)+cost[x-1], F(x-2)+cost[x-2])
>       1. 这一步有点像递归里面,F(x-1)即之前步骤中的最优结果,交给之前那一步去选择
>       2. 自顶向下?,如何将这一步转换为自底向上呢?
>          1. min(F(x)+cost[x], F(x+1)+cost[x+1])
> 3. dp数组如何初始化
>    1. F()
> 4. 确定遍历顺序
> 5. 举例推导dp数组





```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dest = cost.size();
        if(dest < 2) return 0;
        int dp0 = cost[0];
        int dp1 = cost[1];
        for(int i = 2; i<dest; i++)
        {
            int dpi = min(dp0,dp1)+cost[i];
            dp0 = dp1;
            dp1 = dpi;
        }
        return min(dp0, dp1); 
    }
};

// 	题解比我好在哪里?
对于dp数组下标的含义:
	我的含义 dp[i]的含义是: 我从开始到站在第i个台阶上的cost (脚还在i上)
    答案的含义 dp[i]的含义是: 我从i迈出去之后的cost (脚在i+1 或是i+2上)
由此引发的 状态转移方程也发生了变化
        我的: min(F(x)+cost[x], F(x+1)+cost[x+1])
        答案的: dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
// 如何降低空间复杂度?
	答案的状态转移方程中,对于空间的重复利用,是轮转而不是像我之前那样的奇偶变换,
	可以推测的是,对于状态转移方程,你有多少个先前状态,你的数组就需要分配多大即可,然后每一轮进行轮转,或者是用标记表示循环队列

```















#### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

难度中等1596

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171712950.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`



> ### 思路
>
> 我在我目前位置上的路径总数 = 我在我右边位置的路径总数 + 我在我下面的路径总数
>
> 1. 确定dp数组（dp table）以及下标的含义
>    1. 二维数组(m*n),每一位的含义为当前位置的路径总数
> 2. 确定递推公式
>    1. dp(x,y) = dp(x+1,y)+dp(x,y+1) // 这里就将start设置为左下角,dest设置为右上角,只能向右向上移动
> 3. dp数组如何初始化
>    1. dp(m,y) = 1
>    2. dp(x,n) = 1
> 4. 确定遍历顺序
>    1. 可以想到,当矩阵中的一个点,右边和下边存在结果,那么这个点的结果就可以得到
>    2. 对于每行来说,从右向左进行
>    3. <img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171712214.png" alt="image-20221105115005277" style="zoom: 25%;" />
> 5. 举例推导dp数组

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // 建立二维数组
        vector<vector<int>> dp (m, vector<int>(n,0)); // 初始化 m*n的矩阵
        for(int i = 0; i<m; i++) dp[i][0] = 1;  // 第0列
        for(int j = 0; j<n; j++) dp[0][j] = 1;  // 第0行
        for(int x = 1; x<m; x++){
            for(int y = 1; y<n; y++)
            {
                dp[x][y] = dp[x-1][y] + dp[x][y-1];
            }
        }
        return dp[m-1][n-1];


        // 循环遍历
    }
};

```







#### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

难度中等905

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

 

**示例 1：**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171712697.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

**示例 2：**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171712571.jpg)

```
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
```

 

**提示：**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`



> ### 思路
>
> 延续上面的思路:
>
> ​	我在我目前位置上的路径总数 = 我在我右边位置的路径总数 + 我在我下面的路径总数
>
> ​	判断是否存在障碍,如果存在障碍,则该点置为 -1;
>
> 几个坑:
>
> ​	对于 dp [x] [y],如果要画图来具象化, 一维数组应当是 ↑↑↑ 这样排列, 否则会对不上
>
> ​	对于矩阵的两条边进行初始化,意味着交点会处理两次,这需要注意
>
> ​		而如果单纯地绕过了(0,0)这个点之后,当(0,0)=1时,也会产生错误,应该在最开始对(0,0)单独处理
>
> **something new**
>
> - 初始化一个二维数组



```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        // 遍历数组,对其进行初始化
            // 1. 对于边上的数组, 置为1
            // 2. 对于障碍数组,置为-1
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(obstacleGrid[0][0] == 1)
        {
            for(int x = 0; x<m; x++) obstacleGrid[x][0] = -1;
            for(int y = 0; y<n; y++) obstacleGrid[0][y] = -1;
        }
        for(int x = 0; x < m; x++)  // 第0行
        {
            if(obstacleGrid[x][0] == 0){
                obstacleGrid[x][0] = 1;
                continue;
            } 
            // 将障碍以及之后的全部取为-1
            for(int i = x; i < m; i++){
                obstacleGrid[i][0] = -1;
            }
            break;
        }
         
        for(int y = 1; y < n; y++)  // 第0行
        {
            if(obstacleGrid[0][y] == 0){
                obstacleGrid[0][y] = 1;
                continue;
            } 
            // 将障碍以及之后的全部取为-1
            for(int j = y; j < n; j++){
                obstacleGrid[0][j] = -1;
            }
            break;
        }

        for(int x = 1; x<m; x++){
            for(int y = 1; y<n; y++){
                if(obstacleGrid[x][y] == 1) obstacleGrid[x][y] = -1;
            }
        }

        // 循环遍历数组
        for(int x = 1; x<m; x++){
            for(int y = 1; y<n; y++)
            {
                int a = obstacleGrid[x-1][y];
                int b = obstacleGrid[x][y-1];
                // 两种情况, 等式左边是 -1, 或者等式右边是-1
                if(obstacleGrid[x][y] == -1)  continue;
                if(obstacleGrid[x-1][y] == -1) a=0;
                if(obstacleGrid[x][y-1] == -1) b=0;
                obstacleGrid[x][y] = a+b;
            }
        }
        if(obstacleGrid[m-1][n-1] == -1) return 0;
        return obstacleGrid[m-1][n-1];
        return obstacleGrid[0][0];
    }
};

// 答案和我的有什么不同
	// 答案重新开辟了一个二维数组 
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
	if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0
            return 0;
        vector<vector<int>> dp(m, vector<int>(n, 0)); // 在栈中创建一个二维数组的方法
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue; // 遇到障碍将其置为0即可
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};

```







#### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

难度中等969

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```  
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。 n=2应该需要单独处理?
n = 3 return 2
n = 4 return 4 
n = 5 return 6 
n = 6 return 9 (2*2*2 = 8) (3*3=9)
n = 7 return 12 (2*2*3 = 12)
n = 8 return 16 (4*4 = 16) (3*3*2 = 18)
n = 9 reutrn (4*5 = 2*2 * 3*2 = 20) (3*3*3 = 27)
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 
```

 

**提示:**

- `2 <= n <= 58`



> **思路**
>
> - 到最后,每一个数都分解为 2,3 的和.
> - 是不是.3越多越好
>   - %3=1, 意味着存在自一个 3+1 化成 2+2更好
>   - %3=2, 意味着此时更好,现在3最多

```cpp
// 这里采用的是 3拆分的数学方法, 是用贪心做的
class Solution {
public:
    int integerBreak(int n) {
        if(n == 2) return 1;
        if(n == 3) return 2;
        int j = n/3;
        int i = n%3;
        // 如果余1, 将3+1变成2+2
        if(i == 1) return pow(3,j-1)*4;
        if(i == 2) return pow(3,j)*2;
        return pow(3,j);
    }
};
```



```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) { // 
            for (int j = 1; j < i - 1; j++) { // 对所有因式进行遍历
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); // (i-j)*j i-j不再拆分和 dp[i-j]*j i-j继续拆分 
            }
        }
        return dp[n];
    }
};
// 为什么要取 max( i-j, dp(i-j))?
	// 因为 i-j = i-j + 0 这种拆分不能纳入到dp中去, 0作为因子会使乘积为0
// 为什么拆分时,只有i-j继续拆分,而没有对j继续拆分?
	// 因为在遍历时,会有j不可再分的情况,这种会包含对j拆分的情况
```















#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

难度中等1987

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 

**示例 1：**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171711112.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

 

**提示：**

- `1 <= n <= 19`



> #### 思路
>
> ###### 我的思路
>
> 针对于新加入的结点,情况分为三种
>
> - 插入原树,作为其叶子结点
> - 作为原树的根
> - 这一种情况就是比较不知道怎么办的情况, 插入到原树,但是作为了其子树的根



> ###### 答案的思路
>
> 由于是二叉搜索树,所以当根确定时,其左右子树的结点数目是确定的
>
> 比如在(1,2,3,4)结点组成的树中,当根节点是3时,左子树一定有2个结点,右子树一定有1个结点
>
> 
>
> dp[i] += dp[j - 1] * dp[i - j];
>
> dp[1] = dp[0] * dp[0] 
>
> dp[2] = dp[0] * dp[1] + dp[1] * dp[0]
>
> 
>
> 关键在于,不在乎左右子树中具体是哪些结点,重要的是根左右的子树的==node个数==,将问题分解为 左右node个数 的n种组合

```cpp
class Solution { 
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```



> 这个题的关键在于,树的形状确定之后,这个树中,每个点对应的数字是唯一的,
>
> ​	因为这个树的中序遍历结果唯一,所以在该树形上的结点顺序唯一
>



其实 二叉搜索树的数目 和之前的 整数拆分有异曲同工之处,都是需要将一个值分解为其他值的和,然后当前的dp[i]是该对分解的组合的一些处理结果,整数拆分中是max,而二叉搜索树中是∑









#### 背包问题

![image-20230115130050254](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171711401.png)





##### 01背包

有n件物品和一个最多能背==重量bagweight==为w 的背包。第i件物品的重量是==weight[i]==，得到的价值是==value[i]== 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和==最大==

- 背包容积: bagweight = w
- 货物重量: weight[]
- 货物价值: value[] 





##### 二维dp

[代码随想录 (programmercarl.com)](https://www.programmercarl.com/背包理论基础01背包-1.html#二维dp数组01背包)

<img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171711861.png" alt="image-20230115135848683" style="zoom: 50%;" />

**dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

 ==dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);==



如果我选择拿起第i件物品,那么我的价值总和 = i的价值 + 扣去了代价的dp



> ##### 第一行的内容是什么?
>
> ​	指的是在只有物品0时,在不同容积下的存储情况
>
> ##### 第一行在何时初始化?
>
> ​	对于二维数组, 第一行需要单独初始化, 也就是判断只有物品0时的装载情况
>
> ​	对于一维数组, 第一行初始化的过程在判断不能拿起物品后,`if (j < weight[i]) dp[j] = dp[j]`,便完成了初始化,之所以二维数组不可以完成,是因为`dp[i][j] = dp[i - 1][j]`中,当i=0时,i-1= -1
>
> 
>
> ##### 为什么要这么遍历?
>
> ​	为什么要从上到下?
>
> ​		因为物品的加入是从少到多的,从1->n的,只有知道规模为1的情况,才能向上递推到n
>
> ​		
>
> ​	我认为和动态规划的逻辑有关系, 我们在做动态规划时,求解元素数量为n的这么一个问题规模,我们所能知道的是,当元素数量是n-1时,怎么从 n-1 到 n, 即状态转移方程所描述的, `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]),` 但其实我们也不知道n-1的具体值,我们所做的是 继续从 n-1 到 n-2 然后一直到 元素数量只有1个时的情况
>
> ​	这种思路其实就是和递归类似,递归就是层层下潜,最后触底,终于得到一个基本的不可再分的,可以得到具体结果的解,然后再步步弹栈,得到元素为n时的解
>
> ​	而动态规划则类似于,我从触底的那个步骤再往上发展,我先去得到,当元素只有一个时这个问题的具体的解,然后通过递推,得到问题规模发展为两个元素之后的解的情况,
>
> ```cpp
> // weight数组的大小 就是物品个数
> for(int i = 1; i < weight.size(); i++) { // 遍历物品
>  for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
>      if (j < weight[i]) dp[i][j] = dp[i - 1][j];  // 1.不能拿起物品i的情况
>      else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); // 2.能拿起但不如不拿的情况 	2.能拿起而且拿起更好的情况
>  }
> }
> // 1. 当前这个物品的重量大于容积 - 直接跳过 - 不进行覆盖 dp[i][j] = dp[i - 1][j]
> // 2. 当其这个物品的重量小于容积
> 	// 2.1 能拿起但是不如不拿  dp[i - 1][j]
> 	// 2.2 能拿起而且拿起来更好  dp[i-1][j-value[j]]+value[j]
> ```
>
> 







##### 一维dp

<img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302171711861.png" alt="image-20230115135848683" style="zoom: 50%;" />



> #### faltten
>
> ​	我的理解是,当我们去构造这个二维数组时,是由左上到右下建立起来的,当我们建立物品2这一行时,只有物品1这一行会被用到,而0其实已经没有用了,所以我们可以在内存中只申请一行的空间,然后对其进行迭代,覆盖前的内容为上一行,覆盖之后的内容为下一行
>
> ​	当我们是先遍历物品然后再遍历重量这种顺序时,要注意到,我们用 dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]来计算下一行时,所用到的都是上一行的数据,所以在覆盖时,要保证覆盖之后的数据不会再次参与到计算中,所以对于该行的计算要从右到左进行
>
> ##### 纵轴从上从上到下, 横轴上从右到左
>
> ​	在进行一维数组求解时,逻辑过程应该是先想二维情况,然后再将其faltten到一维,同时固定遍历顺序,从上到下,从右到左
>
> ##### 	为什么要从右到左?
>
> ​		在一维数组中,我们faltten了二维数组,  dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);, 根据状态转移方程,我们可以知道,我们求解dp[j]是需要dp[j-weight]的,并且此时的dp[j-weight]要保证是上一次i-1时的值,所以如果从左到右进行遍历,那么产生的改变会有叠加



```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量 - 从右到左
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
// note
	// 1- 初始化
		// dp数组长度为 w+1 因为0会空出来
		// 数组第一行的初始化不需要单独写,因为会在 判断当前物品是否大于容积时 j >= nums[i] 进行初始化
	// 2- 遍历顺序
		// 对于重量的遍历时从右到左的
```



















#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

难度中等1605

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`



> #### 思路
>
> 将一个数组分割成两个相等的子集, 如何将其和动态规划联系起来? 这里面怎样才会有子问题的嵌套情况出现?
>
> 首先将第一个元素作为第一组,其余元素作为第三组,问题变为, 如何将第三组分为 相差nums[1]大小的两个子集?
>
> 1. 然后将第2个元素纳入第一组,问题变为如何将第三组变为相差 gap=nums[1]+nums[2]大小的两个子集?
> 2. 将第2个元素纳入第二组,问题变为如何将第三组变为相差 gap=nums[1]-nums[2]大小的两个子集
>
> 如果最后第三组只剩一个元素,问题变为 此时这个元素的大小是否等于之前那个gap的绝对值
>
> 这是递归的情况,现在要将递归变为动态规划的策略,如何写出状态转移方程呢?
>
> 如果有一个二维数组的话,怎么样去套呢?
>
> 能不能和01背包所联系起来?
>
> 背包是怎么样拿能够到达最大
>
> 
>
> ==可以去计算数组的和sum,然后转化为 w=1/2 sum的01背包问题,去计算这种情况下最大的背包重量,将其和1/2 sum所比较是否相同==



```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 01背包问题 w = 1/2 sum ,value数组和weight数组相同
        int sum = 0;
        for (auto it:nums){
            sum += it;
        }
        if (sum % 2 == 1) return false;
        int w = 0.5 * sum;

        // 采用一维数组解决背包问题
        vector<int> dp (w+1, 0);
        // 1.对物品进行for循环
        for(int i = 0; i < nums.size(); i++){
            // 2.对容积进行遍历 这个要从右往左遍历
                // 三种情况
                    // 1. 当前这个物品的重量大于容积 - 直接跳过 - 不进行覆盖
                    // 2. 当其这个物品的重量小于容积
                        // 2.1 拥有该物品之后的背包存储 - dp[i-1][j-value[j]]+value[j]
                        // 2.2 没有拥有该物品之后的背包存储 - dp][i-1][j]
                // 对于压缩成一维数组之后 dp[j] = max(dp[j-value]+value, dp[j])
                // 对于第一组,要么满足第一种情况,要么不满足.
            for(int j = w; j >= nums[i]; j--){
                dp[j] = max(dp[j-nums[i]]+nums[i], dp[j]);
            }
        }
        if(dp[w] == w) return true;
        return false;
    }
};

// note
	// 1- 初始化
		// dp数组长度为 w+1 因为0会空出来
		// 数组第一行的初始化不需要单独写,因为会在 判断当前物品是否大于容积时 j >= nums[i] 进行初始化
	// 2- 遍历顺序
		// 对于重量的遍历时从右到左的
```















#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

难度中等597

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。



**示例 0：** 

```
输入：stones = [1,1,1,2]
sum = 5
w = 2
weight = 2
gap = sum -2w = 1

输入：stones = [1,1,3,2]
sum = 7
w = 3
weight = 3
gap = sum - 2w = 1

输入：stones = [1,1,5,2]
sum = 9
w = 4
weight = 4
gap = sum - 2w = 1
```

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

组合 2 和 7，得到 5，所以数组转化为 [5,4,1,8,1]，
组合 5 和 4，得到 1，所以数组转化为 [1,1,8,1]，
组合 1 和 1，得到 0，所以数组转化为 [8,1]，
组合 8 和 1，得到 7 这不是最优值

sum = 23
w = 11
weight = 11

```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`



> #### 思路
>
> 其实也是相当于将数组分为两个子集,满足两个子集sum的差值最小,和前面一题有类似之处,也是采用背包容积为1/2 sum的01背包,在此情况下求得的最大背包重量 weight, 返回的结果gap就是 sum-2weight
>
> ##### 01背包步骤:
>
> 1. 两个循环
>    1. 外循环遍历物品,内循环遍历重量,内循环从外到内,在第一次遍历时实现对第1行的初始化



```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (auto it : stones){
            sum += it;
        }
        // 如果sum为奇数,则w去一
        int w = 0.5 * sum;
        vector<int> dp = vector(w+1,0); 
        for(int i = 0; i < stones.size(); i++){
            for(int j = w; j >= stones[i]; j--){
                dp[j] = max(dp[j],dp[j-stones[i]] + stones[i]);
            }
        }
        return sum - 2*dp[w];
    }
};

// note
/*
	1-  j >= stones[i] 这里的等号是因为当等于该weight时是能够携带该货物的
	2- dp[j] = max(dp[j],dp[j-stones[i]] + stones[i]); 这里是取 原本的重量 和 携带该物品的重量 的max,而不是无条件的迭代
*/
```























#### [494. 目标和](https://leetcode.cn/problems/target-sum/)

难度中等1507

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

 

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`





> 思路:
>
> - 通过暴力求解的话,遍历 2^length 次,对所有组合进行遍历,对满足条件的情况进行count
>
> 考虑到动态规划 - 这个问题联系到背包问题 - 01背包问题是对货物数组进行挑选 - 这个问题是对货物数组中必须挑选,需要从1和-1中对其系数进行选择
>
> 递归:
>
> 将数组中的最后一个元素,加或者减到target上 -> 转化到动态规划
>
> dp[n] [target] = dp[n-1] [target + data[n]] + dp[n-1] [target - data[n]]



我的思路,将最终所需结果拆分, `dp[n] [target] = dp[n-1] [target + data[n]] + dp[n-1] [target - data[n]]`

用递归去写这个解决过程是简单直接的,但是如何运用动态规划并不知道,难点在于不知道该如何确定过程

```CPP
// 递归思路
class Solution {
public:
    int func(int n, int target, vector<int>& nums) {
        if (n == 1) {
            if (nums[0] == target && target==0) return 2;
            if (nums[0] == target || nums[0] == target*-1) return 1;
            return 0;
        }
        return func(n - 1, target + nums[n-1], nums) + func(n - 1, target - nums[n-1], nums);
    }

     int findTargetSumWays(vector<int>& nums, int target){
        return func(nums.size(), target, nums);
    }

};
```





###### 动态规划思路

> 对于数组中的元素进行分类,left和right两类(left前面的符号为正,right前面的符号为负,两者的绝对值的和为sum,产生的结果为left-right=target)
>
> target = left - right
>
> sum = left + right
>
> 可以通过target,sum来构造left, left = (target+sum)/2,
>
> 由于, sum和target都是给定的, 
>
>  ==所以问题转化为,在数组中挑选出子集,其和为(target+sum)/2==
>
> - bagweight = left
> - value[] = nums[]
> - weight[] = nums[] 
>
> ---
>
> 同时,我们之前所解决的背包问题为==在一定背包容积下的最大能装载货物重量==,而这里我们所解决的是在这些货物中,能够达到容积的组合数目
>
> 其实这题现在看来有点像[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/),只不过这个题是针对于,是否能够达到指定重量(1/2背包容积),而这题是要求达到指定重量的组合数目
>
> ##### 解决方法:
>
> - dp[j]: 填满容量volume为j的背包,共有dp[j]种方法
> - 如果从货物中拿出一个物品i,其重量为nums[i]
>   - 如果纳入背包, 则到达目标j,还需要 ==dp[j-nums[i]]==种方法
>   - 如果不纳入背包,则还需要==dp[j]==种方法
>   - question: 为什么纳入之后的方法是dp[j-nums[i]]呢? 会不会将物品nums[i]纳入两次呢?
>     - 注意,此时的纳入和不纳入是两个并行的方法,==即这两种的dp数组都是暗含了,nums[]中剔除了物品i之后去计算的下一步的方法数量==
>     - 相当于二维数组解法中的纵轴,遍历物品i这一过程,被简化了,被faltten了,所以其遍历过程没有显示的表达出来,其实放到二维中,`dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]`
> - 所以遍历过物品i之后, ==dp[j] += dp[j-nums[i]]==
>   - 
>   - ==组合类==的问题
>
> ```cpp
> // bagsize = target
> //  组合方式
> // 从上到下, 从右到左
> // 递归视角: 集合中拿掉最后一个物品 dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]
> // 动态规划视角: 集合中多了一个物品
> 
> // 1. 当前这个物品的重量大于容积 		dp[i][j] = dp[i - 1][j]
> // 2. 当其这个物品的重量小于容积 		dp
> ```
>
> 
>
> 

```cpp
// 动态规划思路
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(auto it: nums)
        {
            sum+=it; //对nums求和
        }
        // left + right = sum
        // left - right = target
        // left = 1/2 * (sum+target)
        // 问题转化为, 01背包问题: bagweight = left, value[] = nums[], weight[] = nums[]
        int volume = 0.5 * (sum+target);
        if(abs(target) > sum) return 0; // 预判断一下
        if((sum+target)%2 == 1) return 0; // 如果sum+target不能被2整除,说明不存在left,因为left是其和的1/2

        vector<int> dp (volume+1, 0);
        dp[0] = 1; // 当我的bagsize=0时,如果此时存在 j==nums[i], 即存在物品重量为0,则应是能有一次方法

        // 纵轴遍历 物品nums, 横轴遍历 重量 bagsize <- 0
        // 要faltten纵轴的话,for循环外层为纵轴
        // 纵轴从上到下, 横轴从右到左
        for(int i =0; i < nums.size(); i++){
            for(int j=volume; j>=nums[i]; j--){ // 如果 j<nums[i], 那么肯定不能拿进背包, dp[j]没有变化
                dp[j] += dp[j-nums[i]];
            }
        }
        return dp[volume];
    }
};
```







#### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

难度中等871

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

 

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`



> #### 思路
>
> 有点类似于 01背包重复两次, m和n就是两个bagsize,然后数组中的元素进行解析,得到其weight[], 比如"0101"对应的就是2,2
>
> 这里的value是1, weight是其01个数
>
> 但是相当于同时满足两个weight才能够获得一个value
>
> ==双重代价?==
>
> 逻辑上是外层循环遍历每一个物品,然后再对容量进行遍历? (m和n两个方向上的遍历? )
>
> 这里的逻辑为 三维数组`, dp[i][j][k] = max (dp[i-1][j-nums1[i]][k-nums0[i]] + 1, dp[i-1][j][k])`
>
> 以此为根据构建三维数组的遍历.





```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // 对strs进行解析, 得到 nums0[] 和 nums1[]
        vector<int> nums0(strs.size(), 0);
        vector<int> nums1(strs.size(), 0);
        int i = 0;
        for(auto s : strs)
        {
            for(auto c : s)
            {
                if(c == '1') nums1[i]++;
                if(c == '0') nums0[i]++;
            }
            i++;
        }
        vector<vector<int>> dp (m+1, vector<int>(n+1,0)); // m+1 和 n+1是因为存在背包容积为0的情况,这种也可以进行装载
        
        // 背包问题 双重代价?
        // 这里的逻辑为 三维数组, dp[i][j][k] = max (dp[i-1][j-nums1[i]][k-nums0[i]] + 1, dp[i-1][j][k])
        for(int j = 0; j < strs.size(); j++){
            // m nums0
            for(int k=m; k >= nums0[j]; k--){
                for(int l=n; l >= nums1[j]; l--){
                    dp[k][l] = max(dp[k-nums0[j]][l-nums1[j]]+1, dp[k][l]);
                }
            }
        }
        return dp[m][n];
    }
};
```





















#### 完全背包问题



**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**



​	背包重量为4

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |



> #### 我的思考
>
> ​	我认为可以从性价比入手, 物品0的性价比为15, 物品1的性价比为6.66, 物品2的性价比为7.5, 所以先装物品0,等到装不下了再去看物品2,接着再去看物品1.
>
> ​	但这样也存在一个问题, 可能在物品0接近装满时, 再拿出一个物品0,可以装入更多价值的其他物品

​	

> - ### resolution
>
>   - 01背包中,内循环即容量遍历,是从大到小的,也就是从右到左,是为了保证对于物品i产生的改变不会叠加
>
>   - 但是在完全背包中,由于物品的数量是无限,所以我们可以允许叠加,也需要叠加的产生,所以在完全背包中,==内侧遍历的顺序是从左到右的== (还是有点无法理解)
>
>     - 当遍历到物品i时,首先容量遍历到j,此时进行判断,并做出改变,那么当后面遍历到k时, 如果 k-weight[i]=j, 则会用到已经改变过的dp[j],此时如果进行判断如果加入物品i更好,则继续叠加, 此时物品i已经叠加两次
>
>     - ##### 如果叠加的话,会不会产生,叠加次数比正确结果少的情况,(比如在下一次覆盖叠加时,明明可以叠加3个,却只叠加了2个)
>
>       - 不会,因为容量遍历是原子化的,所以在遍历时,只要能叠加就会叠加上去,不会存在不足.
>
>   - ##### 当物品从 i-1 遍历到 i时,是如何将背包中的 物品i-1拿出来, 给物品i腾地方的?
>
>     - ```cpp
>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
>       // 在这句代码中, dp[j - weight[i]],腾出位置后的背包重量
>       ```
>
> - #### 为什么遍历物品在外侧,遍历容量在内侧?
>
>   - 对于纯完全背包问题,即求解最大背包重量,内外侧遍历的顺序是可以改变的
>   - 但是对于,装满背包有多少种方式,两个for循环的顺序是需要斟酌的
>   
















































































#### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

难度中等999

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回==可以凑成总金额的硬币组合数。==如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 



**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```

 

**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同 ** //之所以不同,是因为每个coin的数量为无穷
- `0 <= amount <= 5000`









> - ### 我的思考
>
>   - `dp[i][j]` : 当遍历到coins[i]时, bagsize=j时的 能够凑到amount的 组合数量
>   - 状态转移方程 : `dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]];`
>     - 首先,思考当我们位于 `dp[i-1][j]`时,此时纳入一个新的物品i, 原有的组合数量肯定不会改变, 我们需要考虑 用容积换取该物品之后的情况, 即 `dp[][j-coins[i]]`的情况, 但同时要考虑到,我们此时coins的数量无限,所以应当是 `dp[i][j-coins[i]`,
>
> 
>
> - ### my solution
>
>   ```cpp
>   class Solution {
>   public:
>       int change(int amount, vector<int>& coins) {
>           // 首先尝试一下,先遍历背包,再遍历物品
>           // 先写一次二维数组的
>           if(amount == 0) return 1;
>           if(coins.size() == 1){
>               if(amount % coins[0] == 0) return 1; // 能够整除 返回1
>               return 0; // 不能整除 返回0
>           }
>           vector<vector<int>> dp (coins.size(), vector<int>(amount+1, 0));
>           for(int i = 0; i < coins.size(); i++){
>               dp[i][0] = 1;
>           }
>           for(int i = 0; i <= amount; i++){
>               if(i % coins[0] == 0) dp[0][i] = 1; // 整除置为1
>               else dp[0][i] = 0; // 不能整除置为0
>           }
>           for(int i = 1; i < coins.size(); i++){ // 先遍历物品
>               for(int j = 0; j <= amount; j++){ // 再遍历背包
>                   if(j < coins[i]) dp[i][j] = dp[i-1][j];
>                   else{
>                       dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]];
>                   }
>               }
>           }
>           return dp[coins.size()-1][amount];
>       }
>   };
>   ```
>
>   



> ## 答案
>
> - #### 动态规划
>
>   - dp[j] - 凑成总金额j的货币组合数量
>
>   - dp[j] += dp[j-coins[i]]  状态转移方程
>     - 未纳入前 + 纳入后减少质量
>
>   - 遍历顺序 假设 coins[0] = 1，coins[1] = 5
>
>     - ##### ==组合数和排列数的区别==(还是有点不明白)
>
>       - 组合数: 如果是先遍历物品,后遍历背包, 那么会先加入钱币1, 再加入钱币5, 得到的方法是{1,5}而不会有 {5,1}
>       - 排列数: 而如果先遍历背包,再遍历物品, 那么此时会既有 {1,5} 也会有{5,1}
>
>     - 辅助理解
>
>       - 对于 a,b两件物品,如果是先遍历物品的话,那么只会有a->b 而不会有b->a的顺序
>
> - ##### 为什么初始化的时候, dp[j] += dp[j - coins[i]], 不会导致递增吗(叠起来了 1,2,3,4,5)?
>
>   - 因为原先的 dp[j]=0, 所以也相当于自动完成了初始化
>   - 而在后面的遍历中,这个操作相当于在原有基础上进行 2个1换 1个2的兑换过程, 并且要求从左向右进行,来保证叠加效果
>
> - ##### Solution
>
>   - 
>
>   - ```cpp
>     class Solution {
>     public:
>         int change(int amount, vector<int>& coins) {
>             vector<int> dp(amount + 1, 0);
>             dp[0] = 1;
>             for (int i = 0; i < coins.size(); i++) { // 遍历物品
>                 for (int j = coins[i]; j <= amount; j++) { // 遍历背包
>                     dp[j] += dp[j - coins[i]];
>                 }
>             }
>             return dp[amount];
>         }
>     };
>     ```
>
>   - 



























#### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

难度中等754

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`



> ### 思考
>
> 将前面那个题(凑硬币)中的内外循环替换



> ### solution
>
> ```cpp
> 
> class Solution {
> public:
>  int combinationSum4(vector<int>& nums, int target) {
>      vector<int> dp(target + 1, 0);
>      dp[0] = 1;
>      for (int i = 0; i <= target; i++) { // 遍历背包
>          for (int j = 0; j < nums.size(); j++) { // 遍历物品
>              if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) { // 看不懂
>                  dp[i] += dp[i - nums[j]];
>              }
>          }
>      }
>      return dp[target];
>  }
> };
> ```

















#### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

难度中等2310

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

 

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`



> ## 思考
>
> - ##### 动态规划
>
>   - dp[j]含义 - 凑成target=j的最小硬币个数
>     - dp初始化 - 上边界
>     - dp[0] - 0 
>   - i - 物品迭代, j - 容量迭代
>   - 状态转移方程 - min(dp[j],dp[j-coins[i]]+1)
>     - 要求硬币数量最小 -> 如果将当前的物品i纳入会使得硬币数更少,那就纳入 -> 取min
>   - 如何完成初始化? 最开始的dp中都是0,取min的话会都是0
>     - ==如果是取min的话,需要将原dp数组中的值取为上边界 max,而不是下边界0==
>
>   
>
>   
>
> ```cpp
> class Solution {
> public:
>     int coinChange(vector<int>& coins, int amount) {
> 
>         vector<int> dp (amount+1, 10001); // 取为上边界
>         dp[0] = 0;
>         for(int i = 0; i < coins.size(); i++){ // 外侧遍历物品
>             for(int j = 0; j <= amount; j++){ // 内侧遍历容量
>                 if(j>=coins[i]) dp[j] = min(dp[j],dp[j-coins[i]]+1);
>             }
>         }
> 
>         return dp[amount] == 10001 ? -1 : dp[amount];
>     }
> };
> ```
>
> 答案和我差不多

















































#### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

难度中等1627

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的`最少数量`* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示：**

- `1 <= n <= 104`



> ## 思考
>
> ​	我的理解是,[1,4,9,16]这些完全平方数就像货物一样,要求能够达到target的最小货物数量
>
> ##### 动态规划
>
> - dp[j],达到容积为j的物品的最小数量
> - dp[j] = min(dp[j],dp[j-nums[i]]+1)
> - 由于是取最小数量,初始值应当设为上限,dp[0]应当设为0

















































#### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

难度中等1966

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

 

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅有小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**



> ## 思路
>
> ​	这题和之前见过的都不太一样,因为采用到了字符串拼接,所以对于容积的计算需要重新考虑
>
> - #### 递归思路
>
>   - 首先当遍历到 wordDict[i]=word时, 假设word能将s划分为3段,s=left+word+right,这样就可以将问题拆分, dp(word)=dp(left)+dp(word)+dp(right)
>
> - #### 动态规划
>
>   - dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。
>   - 当j小于i时,如果dp[j]为true,且在i到j之间这段可以在字典中出现,那么dp[j]也为true
>     - 可以看到这里和我所想的有个区别,即left为规模变小之后的s, 而right为所需在s中find的word
>
> ## solution
>
> - dp[i] : ==对于字符串s(0,i)，dp[i]为true，表示可以拆分。==
>
> - 状态转移方程: if (wordSet.find(word) != wordSet.end() && dp[j])  dp[i] = true;
>
>   - 这里是拆分为两段left,right. 如果 right在wordSet中有,且 left=true,那么整段则为true
>   - 先从0到n依次增长子串的长度,然后再判断这个子串是否为true,再用子串是否存在来推导,子串+right 是否存在
>   
>   ​      
>
> ```cpp
> class Solution {
> public:
>     bool wordBreak(string s, vector<string>& wordDict) {
>         unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
>         vector<bool> dp(s.size() + 1, false);
>         dp[0] = true;
>         for (int i = 1; i <= s.size(); i++) {   // 遍历背包, 根据i遍历字符串
>             for (int j = 0; j < i; j++) {       // 遍历物品
>                 string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
>                 if (wordSet.find(word) != wordSet.end() && dp[j]) {
>                     dp[i] = true;
>                 }
>             }
>         }
>         return dp[s.size()];
>     }
> };
> ```
>
> 























































#### 多重背包



01背包 - 只有一件可用

完全背包 - 每件无限

多重背包 - 每个物品分别有xi件可用



> #### 做法
>
> ​	将多重背包摊开,转化为01背包
>
> <img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202303032145476.png" alt="image-20230303212326499" style="zoom:50%;" />
>
> <img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202303032145824.png" alt="image-20230303212353355" style="zoom:50%;" />





























































#### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

难度中等2455

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`







> ### 我的思考
>
> ##### 动态规划
>
> - dp[j] - 对于长度为j的nums的所能得到的最大金额
>
> - 状态转移: dp[j] = max(dp(j-1), dp(j-2)+nums[j])
>
>   ```cpp
>   class Solution {
>   public:
>       int rob(vector<int>& nums) {
>           if(nums.size() == 1) return nums[0];
>           vector<int> dp(nums.size(), 0);
>           dp[0] = nums[0];
>           dp[1] = max(nums[0],nums[1]);
>           if(nums.size() == 2) return dp[1];
>           for(int i = 2; i < nums.size(); i++){
>               dp[i] = max(dp[i-1], dp[i-2]+nums[i]);
>           }
>           return dp[nums.size()-1];
>       }
>   };
>   ```
>
>   









































































#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

难度中等1284

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：3
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`





> ## 我的思考
>
> 这道题相比于之前的版本1,之前的dp都是 n-1->n 由这个顺序去递推,但是这道题中,收尾也能相互影响了
>
> - [2,3,2,3,3] 中 首和尾不能同时纳入背包, 结果为6
> - 除了带来限制还能不能带来更多可能?
>   - 如果在版本2中能够成立的序列,那么在版本1中肯定也能成立,反之则不是
> - 当遍历到物品n时,怎么知道物品0是否被纳入?
>   - 建立一个 has_head 的flag数组来判断是否包含head
> - ~~是否可以,如果对于收尾都占用的情况,就将数组向后循环移动一格,然后再来计算一次~~
>   - 是否只要移动一次就可以找到?
>   - 好像不可以,对于[2,3,2,3,3]这样,无论从哪里开头,都不可以,因为其最大的情况就是首尾都不要
>
> ## solution
>
> 对于环所带来的限制,考虑三种情况
>
> 1. 不包含首元素
> 2. 不包含尾元素
> 3. 不包含首尾元素
>
> 既然1和2都包含了情况3,所以取1,2的max即可
>
> 理解：在此题中,所能取得的最大值的序列,要么掐头,要么去尾,这里的序列指的是子串,所以我们可以直接直接将nums的范围减小,nums掐头或去尾之后再去计算两种情况的最大值
>
> ```cpp
> class Solution {
> public:
>     int rob(vector<int>& nums) {
>         if (nums.size() == 0) return 0;
>         if (nums.size() == 1) return nums[0];
>         int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
>         int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
>         return max(result1, result2);
>     }
>     // 198.打家劫舍的逻辑
>     int robRange(vector<int>& nums, int start, int end) {
>         if (end == start) return nums[start];
>         vector<int> dp(nums.size());
>         dp[start] = nums[start];
>         dp[start + 1] = max(nums[start], nums[start + 1]);
>         for (int i = start + 2; i <= end; i++) {
>             dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
>         }
>         return dp[end];
>     }
> };
> ```
>
> 
>
> 





























































































#### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

难度中等1567

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

 

**示例 1:**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202303040956400.jpeg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202303040956406.jpeg)

```
// 示例二中的4和5并不在从root延伸的同一条分支上,所以此题的root强调的是二叉树结构,而不是入口所带来的遍历顺序
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```

 

**提示：**



- 树的节点数在 `[1, 104]` 范围内
- `0 <= Node.val <= 104`



> ## 我的思考
>
> 这题和版本1的联系在于
>
> - 版本1中是 n-1,n-2-> n
> - 此题中是 n-1层,n-2层 -> n
>
> 二叉树:
>
> - 左孩子 2x + 1
> - 右孩子 2x + 2
> - 左左 2(2x+1) + 1 = 4x + 3
> - 左右 4x + 4
> - 右左 4x + 5
> - 右右 4x + 6
> - 叶节点 - 
>
> dp[i] = max((dp[2x+1]+dp[2x+2]) + (dp[4x]... + nums[i]);
>
> #### 动态规划
>
> 这个题中的递推关系究竟是什么? 当范围扩大时,怎么由前一步得到下一步
>
> 我认为在此题中,可以是由 树 -> 子树 的递推,但是这种关系在数组存储的二叉树中显得很不好处理(能先转化成二叉树吗? ->不用了,题目只是输入采用的数组,但是函数的参数输入时二叉树)





```cpp
class Solution {
public:
    // 先用递归写吧
    int rob(TreeNode* root) {
        return max_reward(root);
    }

    int max_reward(TreeNode* curr_root){
        if(curr_root == nullptr){
            return 0;
        }
        int left = max_reward(curr_root->left);
        int right = max_reward(curr_root->right);
        int left_left;
        int left_right;
        int right_left;
        int right_right;
        if(curr_root->left != nullptr){
            left_left = max_reward(curr_root->left->left);
            left_right = max_reward(curr_root->left->right);
        }
        else{
            left_left = 0;
            left_right = 0;
        }

        if(curr_root->right != nullptr){
            right_left = max_reward(curr_root->right->left);
            right_right = max_reward(curr_root->right->right);
        }
        else{
            right_left = 0;
            right_right = 0;
        }
        return max(left+right, left_left+left_right+right_left+right_right+curr_root->val);
    }
};
// 调用递归结果超时, 原因是产生了重复计算, 这个节点可能作为 子代被计算,也可能被作为孙代被计算,这两次计算不能重用,所以产生了重复计算
	// 可以采用一个 map 来记录每个节点的计算结果,防止重复计算

class Solution {
public:
    unordered_map<TreeNode* , int> umap; // 记录计算过的结果
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        if (umap[root]) return umap[root]; // 如果umap里已经有记录则直接返回
        // 偷父节点
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); // 跳过root->left
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); // 跳过root->right
        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
        umap[root] = max(val1, val2); // umap记录一下结果
        return max(val1, val2);
    }
};
```



> ### solution
>
> 对树中节点进行登记, 记录其 包含root 和 不包含root的 最大结果(这里的包含不是指可包含, 而是确切的包含)
>
> ```cpp
> class Solution {
> public:
>     int rob(TreeNode* root) {
>         vector<int> result = robTree(root);
>         return max(result[0], result[1]);
>     }
>     // 长度为2的数组，0：不偷，1：偷
>     vector<int> robTree(TreeNode* cur) {
>         if (cur == NULL) return vector<int>{0, 0};
>         vector<int> left = robTree(cur->left);
>         vector<int> right = robTree(cur->right);
>         // 偷cur，那么就不能偷左右节点。
>         int val1 = cur->val + left[0] + right[0];
>         // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
>         int val2 = max(left[0], left[1]) + max(right[0], right[1]);
>         return {val2, val1};
>     }
> };
> // int val2 = max(left[0], left[1]) + max(right[0], right[1]);
> // 疑惑 - 为什么这里还要取max([0],[1]), 也就是说存在 包含比不包含要小的情况
>     因为这里的包含是必须包含,而不是可以包含 - 所以是存在包含之后反而要小的情况的
> // 疑惑 - 那如果 left和right的都是包含比不包含要小,那么此时是可以纳入cur节点的
> 	即使包含之后更大,也是不可以包含的
> ```
>
> 













#### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

难度简单2838

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`





> ### 我的思考
>
> 1. 找到min和max， 如果min在max前则可以直接得到答案
> 2. 如果min在max后，那还是需要用到dp的思想
>
> ##### 动态规划
>
> - dp[i] - 在前i天的最大收益
>
> - 需要记录买入时的价格 
>
>   - 能否所有dp元素都用同一个买入价格?
>     - {2,10,1,5} - 这种情况下,1是不能作为买入价格来参与到对于5的dp计算的
>
> - dp[i] = max(dp[i-1], nums[i] - cost[i])
>
>   ```cpp
>   class Solution {
>   public:
>       int maxProfit(vector<int>& prices) {
>           int length = prices.size();
>           if(prices.size() < 2) return 0;
>           vector<int> dp(length, 0);
>           vector<int> min_cost(length, 0); // 前i个元素中的min? 
>           min_cost[0] = prices[0];
>           for(int i = 1; i < length; i++){
>               if(dp[i-1] > prices[i]-min_cost[i-1]){// 不买curr
>                   min_cost[i] = min(prices[i],min_cost[i-1]);
>                   dp[i] = dp[i-1];
>               }else{ // 买curr
>                   min_cost[i] = min_cost[i-1];
>                   dp[i] = prices[i] - min_cost[i-1];
>               }
>           }
>       
>           return dp[length-1];
>       }
>   };
>       
>   ```
>   
>   ### Solution
>   
>   ```cpp
>   class Solution {
>   public:
>       int maxProfit(vector<int>& prices) {
>           int len = prices.size();
>           if (len == 0) return 0;
>           vector<vector<int>> dp(len, vector<int>(2));
>           dp[0][0] -= prices[0];
>           dp[0][1] = 0;
>           for (int i = 1; i < len; i++) {
>               dp[i][0] = max(dp[i - 1][0], -prices[i]);
>               dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
>           }
>           return dp[len - 1][1];
>       }
>   };
>   ```
>   
>   
>
> 



































#### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

难度中等2012

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

 

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`



> ### 我的思路
>
> 由于是无限次的购入购出,所以如果用之前对每次都进行dp遍历的话,就需要 2size*size大小的二维数组
>
> 
>
> #### Solution
>
> 第i天持有股票即`dp[i][0]`，
>
> - 如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`
> - 如果在第i天前就持有股票, 所得现金就是 `dp[i-1][0]`
>
> 还是要将持有股票和最小股价所区分开,虽然在只有一次交易的时候,这两者的差别并不大,
>
> 但是持有股票强调的是 持有/非持有 的两种状态, 方便理解状态之间转移的变化.
>
> 如果第i天不持有股票即`dp[i][1]`的情况， 依然可以由两个状态推出来
>
> - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
> - 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`
>
> ```cpp
> class Solution {
> public:
>     int maxProfit(vector<int>& prices) {
>         // 无限次的买入卖出
>         vector<vector<int>> dp(prices.size(), vector<int>(2,0));
>         dp[0][0] -= prices[0];
>         dp[0][1] = 0;
>         for(int i = 1; i < pri	ces.size(); i++){
>             dp[i][0] =  max(dp[i-1][0], dp[i-1][1]-prices[i]); // 持有
>             dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]); // 不持有
>         }
>         return dp[prices.size()-1][1];
>     }
> };
> // 需要理解的是,对于第i天的持有和不持有 相当于一个状态, 他可以是前一天的状态延续,也可以是前一天的状态改变.
> 
> ```
>
> 

















#### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

难度困难1345

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 105`





> ### 我的思路
>
> ​	将数组划分为左右两个,然后在两边分别求股票收益最大值, 然后遍历划分位置,再取max
>
> ​	最终超时
>
> ```cpp
> class Solution {
> public:
>     int maxProfit(vector<int>& prices) {
>         int max_ret = 0;
>         int length = prices.size();
>         for(int i = 0; i < prices.size(); i++){
>             max_ret = max(max_ret, max_profit(prices,0,i)+max_profit(prices,i,length-1));
>         }
>         return max_ret;
>     }
> 
>     int max_profit(vector<int> prices, int from, int to){ // from 和 to 是闭区间
>         // 区间上的单次购入的股票收益最大值
>         if(from == to){
>             return 0;
>         }
>         int length = to-from+1;
>         vector<int> min_cost (length, 0);
>         vector<int> dp (length, 0);
>         min_cost[0] = prices[from]; 
>         for(int i = 1; i < length; i++){
>             if(dp[i-1] > prices[from+i] - min_cost[i-1]){ // 不买curr
>                 dp[i] = dp[i-1];
>                 min_cost[i] = min(min_cost[i-1], prices[from+i]);
>             }else{ // 买curr
>                 dp[i] = prices[from+i] - min_cost[i-1];
>                 min_cost[i] = min_cost[i-1];
>             }
>         }
>         return dp[length-1];
>     }
> };
> ```
>
> ## Solution
>
> ```cpp
> class Solution {
> public:
>     int maxProfit(vector<int>& prices) {
>         if (prices.size() == 0) return 0;
>         vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
>         dp[0][1] = -prices[0];
>         dp[0][3] = -prices[0];
>         for (int i = 1; i < prices.size(); i++) {
>             dp[i][1] = max(dp[i - 1][1], 0 - prices[i]); // 这里的max就是min-cost,只不过是因为是负数,所以取max
>             dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
>             dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
>             dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
>         }
>         return dp[prices.size() - 1][4];
>     }
> };
> ```
>
> 动态规划
>
> - dp数组 - 一天一共有五个状态
>
>   - 不操作, 第一次持有,第一次售出,第二次持有,第二次售出 
>
> - 状态转移方程
>
>   - 如果第i天持有股票即`dp[i][0]` 那么可以由两个状态推出来
>
>     - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即`：dp[i - 1][0]`
>     - 第i天买入股票，所得现金就是买入今天的股票后所得现金即`：-prices[i]`
>
>     那么`dp[i][0]`应该选所得现金最大的，所以`dp[i][0] = max(dp[i - 1][0], -prices[i]);`
>
>     如果第i天不持有股票即`dp[i][1]`， 也可以由两个状态推出来
>
>     - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即`：dp[i - 1][1]`
>     - 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即`：prices[i] + dp[i - 1][0]`
>
>     同样`dp[i][1]`取最大的，`dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`
>
>   - 对于第i天第二次持有股票
>
>     - 第i-1天就第二次持有股票 `dp[i-1][2]`
>     - 第i天第二次买入 `prices[i] + dp[i-1][1]`

















#### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

难度困难881

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

 

**提示：**

- `0 <= k <= 100`
- `0 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`



这里是强调了具体的k次,作为参数输入,



> ### 我的思考
>
> 有点奇怪的是,是否可以当天买当天卖来规避必须买入卖出所带来的损失
>
> 用词是最多k次,所以可以少于k次
>
> 1. 是否可以创建一个长度为2k的子vector作为每天的状态
>
>    ```cpp
>    class Solution {
>    public:
>        int maxProfit(int k, vector<int>& prices) {
>            if(prices.size() == 1) return 0;
>            vector<vector<int>> dp (prices.size(),vector<int>(2*k,0));
>            for(int i = 0; i < k; i++){
>                dp[0][2*i] -= prices[0];
>            }
>            // 偶数 - 当天状态为买入, 奇数 - 当天状态为卖出
>            for(int i = 1; i < prices.size(); i++){
>                // 对2k进行填装
>                dp[i][0] = max(dp[i-1][0], -prices[i]);
>                for(int j = 0; j < k-1; j++){
>                    dp[i][2*j+1] = max(dp[i-1][2*j+1], prices[i]+dp[i-1][2*j]); // 卖出
>                    dp[i][2*j+2] = max(dp[i-1][2*j+2], dp[i-1][2*j+1]-prices[i]); // 买入
>                }
>                dp[i][2*k-1] = max(dp[i-1][2*k-1], dp[i-1][2*k-2]+prices[i]);
>            }
>            return dp[prices.size()-1][2*k-1];
>        }
>    };
>    ```
>
>    





























































































#### [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

难度中等1434

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

 

**提示：**

- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`



> ## 我的思考
>
> ​	对于不限次数的买卖股票, 做法是设置 2*n 的二维数组.通过对于前一天的状态进行转移,来得到今天的状态.
>
> 在引入了冷冻期之后,可以将 买入->卖出 这条路的状态转移进行调整
>
> ```cpp
> class Solution {
> public:
>     int maxProfit(vector<int>& prices) {
>         vector<vector<int>> dp(prices.size(), vector<int>(2,0)); // 0-持有 1-不持有
>         if (prices.size() == 1) return 0;
>         if (prices.size() == 2) return max(prices[1]-prices[0], 0);
>         dp[0][0] -= prices[0];
>         dp[1][0] = max(-1*prices[0], -1*prices[1]);
>         dp[1][1] = max(prices[1]-prices[0], 0);
>         for(int i = 2; i < prices.size(); i++){
>             dp[i][0] = max(dp[i-1][0], dp[i-2][1]-prices[i]);
>             dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);
>         }
>         return dp[prices.size()-1][1];
>     }
> };
> ```
>
> 

























#### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

难度中等869

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

**示例 2：**

```
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```

 

**提示：**

- `1 <= prices.length <= 5 * 104`
- `1 <= prices[i] < 5 * 104`
- `0 <= fee < 5 * 104`





> ## 我的思考
>
> 在每次卖出之后的状态转移中,加上对于fee的计算
>
> ```cpp
> class Solution {
> public:
>     int maxProfit(vector<int>& prices, int fee) {
>         vector<vector<int>> dp(prices.size(), vector<int>(2,0));
>         dp[0][0] -= prices[0];
>         for(int i = 1; i < prices.size(); i++){
>             dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]); // 买入
>             dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]-fee); // 卖出
>         }
>         return dp[prices.size()-1][1];
>     }
> };
> ```
>
> 

































