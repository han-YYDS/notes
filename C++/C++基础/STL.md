

#### effective stl 50条建议



##### 第 1 条: 容器类型 - 挑选合适的容器

> 简要介绍了容器的使用场景

区分关联式容器和序列容器: 区别在于是否会因为增删改而导致需要对其余的元素进行移动来保证内存的连续性



- **是否需要在容器的==任意位置插入新元素==？** 如果需要，就选择序列容器否则选择关联容器。
- **是否关心容器中元素是==排序==的？** 如果不关心则哈希容器是一个可行选择方案；否则你要避免哈希容器。
- **需要哪种类型的==迭代器==？** 如果必须是随机访问迭代器(通过下标访问)，则对容器的选择就限定为vector、deque和string。如果要求使用双向迭代器，则避免使用slist和哈希容器。
- **当发生元素的插入和删除操作时候，避免移动容器中原来的元素是否重要？** 如果是就要避免选择序列容器。
- **容器中数据布局是否需要和C保持兼容？** 如果是是只能选择 vector。
- **元素的==查找速度==是否是关键的考虑因素？** 如果是考虑哈希容器。
- **如果容器内部使用==引用计数技术==是否介意？** 如果是则避免使用string因为许多string的实现都是用了引用计数。如果需要表示某种字符串的方法，可以使用vector方法。
- **对插入和删除操作，需要==事务语义==么** 在插入和操作失败的时需要回滚的能力么？如果需要就有使用基于节点的容器，如果需要对多个元素插入操作需要事务，则可以选择list。因为在标准容器中，只有list提供了多个元素的事务语义。但注意：事务语义对编写异常安全代码很重要但同时付出性能上代价。
- **需要使用迭代器、指针和引用失效的次数最少么** 如果是就需要使用基于节点的容器，因为这类对容器的插入和删除从来不会使用迭代器和指针和引用无效；而对连续内存的容器的插入和删除一般会对指向该容器的迭代器和指针、引用变为无效。
- **如果在容器上使用swap使得迭代器失效了会在意吗** 如果在意那么避免使用 string，因为 string 是唯一在STL中 swap 操作过程中导致迭代器、指针和引用无效唯一的容器。
- **如果序列容器迭代器是随机访问，而且只要没有删除操作发生，且插入操作只发生容器末尾，则指向数据的指针和引用就不会变为无效，这样容器是否考虑** 这是一种很特殊的情况，如果是则 deque 满足你的需求，deque 是唯一的迭代器可能会变为无效和指针和引用不会变为无效的 STL 标准容器。





##### 第 2 条: 不要编写独立于容器的代码

> 意思是要写针对于容器的代码,而不要去实现泛型的代码

==试图编写对序列式容器和关联式容器都适用的代码几乎是毫无意义的。==面对实际情况，不同容器是不同的，它们有非常明显的优缺点，不同的适用场景适合选择不同的容器。



##### **第 3 条：确保容器中的对象拷贝正确而高效**

###### copy in, copy out 

> 文章中说, 存入容器和从容器取出的都是拷贝的对象(copy in, copy out) 在这一点上和 深浅拷贝的联系在于?



###### 剥离问题

如果你创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么在派生类对象(通过基类的拷贝构造函数)被拷贝进容器时，它所特有的部分(即派生类中的信息)将会丢失。**剥离问题**意味着向基类对象的容器中插入派生类对象几乎总是错误的。

> 使拷贝动作高效、正确，并防止剥离问题发生的一个简单办法是使容器包含指针而不是对象。



**第 4 条：调用 empty 而不是检查 size() 是否为 0**



在一些容器实现中, size()和empty()的实现的特点,可能导致其两者之间的效率存在差距



list源码

1、Aix

```cpp
size_type size() const

​            {return (_Size); }

 


bool empty() const

​            {return (size() == 0); }
```

 

​    Aix上对于在list中的处理方式依然和vector一样，维护了一个_Size变量，empty()多了一层函数调用，效率较低。




2、Centos

```cpp
size_type size() const

​            { return std::distance(begin(), end()); }

 


bool empty() const

​            { return this->_M_impl._M_node._M_next ==&this->_M_impl._M_node; }
```

 

​    size()函数调用了distance函数用遍历的方法取得两个指针间的元素个数，然后返回。而empty()函数则是判断头指针的下一个节点是否是自己本身，只需要进行一次判断。所以，当list容器元素个数较多的时候，这里的empty()效率远大于size() == 0。



**第 5 条：区间成员函数优先于与之对应的单元素成员函数**

> 即对于容器中一段范围内的元素进行操作的两种方式
>
> 1. 通过描述范围来操作
> 2. 通过遍历这段范围内的每个元素,依次进行操作



优点

- 明智地使用区间插入而不是单元素重复插入会提高程序的性能问题，比如对于vector来说如果内存已满再插入新元素会触发两倍扩容，区间插入不必多次重新分配内存。



有哪些区间成员函数?

​	insert、erase、assign





**第 6 条：当心 C++ 编译器最烦人的分析机制**









#### 序列式容器



##### list

> 概念：list将数据进行链式存储, 即链表

[ C++ list容器详解_c++list容器详解_＆不逝的博客-CSDN博客](https://blog.csdn.net/qq_52324409/article/details/121046388)

