redis的灵魂: 是内存数据库 -> 作为缓存层和持久化数据库搭配使用



#### 1-缓存雪崩,缓存击穿,缓存穿透



##### 缓存雪崩: 

大量的缓存数据同时过期,如果此时产生了大量的用户请求,这些访问由于没有缓存层,直接访问外存数据库,从而产生压力

- 缓存未命中后,需要从数据库中读取数据,然后还需要将数据更新到redis中,构建缓存



**为什么会对键值对设置有效期?**

1. 资源有限,清理不常使用的数据
2. 数据一致性,缓存中的数据可能滞后于数据库中的数据
3. 冷热数据,更频繁访问的数据更有可能留在缓存中这样就能提高性能



**应对方法**

1. 均匀设置过期时间
   1. 很好理解,之前由于都设置为同一个时间,所以导致大量数据同时过期
   2. 实现: 在过期时间上加上一个随机数
2. 互斥锁
   1. 我的理解是,对于同一个键值对的访问,如果第一次访问已经未命中,那么后续的访问应当阻塞,直到其缓存构建完成.
   2. 实现: 互斥锁 - 互斥锁应当设置时间,防止第一次请求产生意外,导致后续访问持续阻塞
3. 双key
   1. 对于一个键值对,设置两个key,key有主次之分,副key的过期时间长于主key,而value相同,相当于做了备份,当主key未命中时,则去访问副key的内容,在缓存构建时,主key和副key中的value都需要更新
      1. 副key被访问可以用来统计当前的雪崩情况,则系统可以进行缓存的异步更新操作,以避免雪崩进一步发生
4. 后台更新
   1. 不设置有效期,将缓存更新的任务交付给后台线程,后台线程定时检测缓存是否有效,如果失效则执行缓存更新
   2. 发现缓存失效时,通知后台线程更新缓存,后台线程查看该键值是否存在,不存在就从数据库读取.
   3. **数据预热**: 在业务上线初期,应该提前将数据缓存,这个任务适合交付给后台更新完成



##### Redis 故障宕机

redis宕机也会造成缓存雪崩,对应这种也有相应的应对方法



**应对方法**:

- 服务熔断或者请求限流
  - **暂停服务**,对于请求直接返回错误
    - 对于保护数据库,服务熔断是可以接受的,但是一旦暂停了数据库,所有业务都会停摆
  - **请求限流**,能够维系基础的服务流量
- **构建高可靠集群**
  - 通过主从节点构造高可靠集群,在节点宕机时,从节点可以提升至主节点继续提供服务



##### 缓存击穿

如果有几个数据频繁被访问到,但某个时刻这个数据过期了,那么大量的请求会直接访问到数据库,数据库会被高并发的请求.

其实这个场景和缓存雪崩比较像

应对方法也是相似的:

1. 对于数据过期的设计
2. 互斥访问



##### 缓存穿透

描述上和缓存击穿有点像,

穿透是指, 数据既不在缓存中也不在数据库中,所以请求会现在缓存找,然后再去数据库找,然后才发现没有找到返回失败信息.

造成缓存穿透的情况有:

1. 业务误操作,不小心把数据在缓存和数据库中都删除掉了
2. 黑客恶意攻击,故意访问一些不可能会存在的键值

其实可以看出,一般是不存在key不存在的现象?

应对方法:

1. 布隆过滤器: 用于快速判断该键值是否存在属于某个集合,当缓存未命中时,通过布隆过滤器来判断是否会在数据库中找到,布隆过滤器存在误判现象

   1. 使用n个哈希函数对key做hash得到n个hash值
   2. 将hash值对数组长度取模,映射到数组上,位示图
   3. 当查询key时,对其求n个hash值,并判断其在位示图中是否都存在

   误判现象: 如果说你存在,有可能是误判(另外一个key也是如此映射的,hash冲突),但如果说你不在,那一定是不在

2. 缓存空对象:++++++++++

3. 热点数据预加载+++++++++++++++++

4. 调整+++++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

demo





++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
