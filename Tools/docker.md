docker的基本使用  

###### 镜像和容器

- 所谓的镜像，就是将一个应用程序与其所依赖的各种环境和配置文件打包成一个文件

- 而所谓的容器就是以一种隔离的方式从镜像当中启动运行这个应用程序  

将应用和其依赖的所有库、运行环境和配置文件打包在一起，这样就可以将应用和其依赖对应起来，再使用隔离机制，让不同的包之间彼此不发生冲突——这个包就是镜像，而对应运行的应用就是容器。  

`解决了环境问题`

特点:隔离



###### 容器和虚拟机的区别  

- 虚拟机
  - <img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302230932743.png" alt="image-20220818170733979" style="zoom:67%;" />
  - 虚拟机工作在Hypervisor的上一层
  - 每个虚拟机都虚拟化出一个**完整的客户操作系统**
  - 当虚拟机中的应用执行时，它会完整地转换成客户操作系统内核的指令，然后经由Hypervisor转交给底层的硬件设施或者宿主操作系统。  
- 容器
  - <img src="https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302230932295.png" alt="image-20220818170916578" style="zoom:67%;" />
  - 没有把内核给虚拟化
    - 多个独立运行的容器拥有自己独立的库和其他依赖
    - 但是操作系统内核却是共享的(相对来说更加轻量级)
  - 将指令翻译成与docker内核适配的,不会再翻译成与宿主机适配的语句,而是交给docker引擎运行,由引擎配合宿主机的内核进行一个统一的操作



不同的容器可以bind相同的端口号 (比如容器1的80端口和容器2的80端口并不会产生冲突)

如果是容器作为服务端,那么是需要知道其ip和端口号,但是对于宿主机的访问对于容器而言是隔离的,所以这里就需要一个端口转发的操作(所以我们可以将容器1的80端口绑定到宿主机的80端口,将容器2的80端口绑定到宿主机的81端口),如果想要访问到容器的内部,就需要将宿主机和容器进行一个端口的映射



#### 命令



-it 将宿主机连进去(可以连接到输出流,将结果在屏幕上打印出来)

-d  守护进程,相当于在后台执行

-p 宿主机:容器 端口映射

-v 宿主机:容器 建立持久化的挂载目录

/bin/bash  启动bash进程,可以持续地输入指令

```
exec -it 1ff165545bc6 /bin/bash
通过exit从bash进程中退出	
```



停掉docker

1. docker ps 找到docker的id
2. docker stop id 停止该docker
3. docker rm id 删除该docker



docker exec -it (容器ID) /bin/bash



保存修改过的操作

docker commit id 

这样就多了一个镜像

再启动时通过镜像启动即可



##### 持久化

容器被删除后,其中的文件依然存在(容器持久化)



###### 挂载

将宿主机中的文件系统中的一个结点,放置在容器中(`挂载` mount - U盘)

​	一个虚拟文件系统下可能有各个不同的物理文件系统,将一个物理文件系统嫁接到虚拟文件系统中的一个节点下,就是挂载的过程

​	通过容器去修改宿主机中的文件,这个改变可以在宿主机中观察到

> 挂载之后的文件,在容器和宿主机中操作的是同一对象 
>
> 但是如果容器被删除掉,其中的文件在宿主机中依然会保存到,这就是持久化的概念

```
实现挂载	
docker run -d -p 83:80 -v /home/han/Cpp_code/20220728/:/usr/share/nginx/html nginx
```



![image-20220819104203753](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302230932992.png)











消息队列如何持久化数据?

### 消息队列

[消息队列之 RabbitMQ - 简书 (jianshu.com)](https://www.jianshu.com/p/79ca08116d57/)



#### 什么叫消息队列

消息（Message）是指在应用间传送的数据。

消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。

消息队列（Message Queue）是一种**`应用间的通信方式`**，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。



#### 为何用消息队列

**`意义在于将同步的消息传递转化为异步`**

起到对于消息的存储转发的效果

从上面的描述中可以看出消息队列是一种**`应用间的异步协作机制`**，那什么时候需要使用 MQ 呢？

以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，`这时可以将一些不需要立即生效的操作拆分出来异步执行`，比如发放红包、发短信通知等。这种场景下就可以用 MQ ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。

- 同步变异步 - 解耦
- 削峰
- 持久化数据

设计消息队列的要点

- 涉及到不同进程之间的通信(这些进程可以是在不同的机器上面)
  - 如果是在不同机器上面的通信,则一定是通过网络
    - 是无连接还是有连接的(TCP or UDP)
    - 交互的协议是什么样子的
- 主动性 - 是阻塞等待(订阅机制-主动去看队列)还是通知(推送机制)
- 限流
- 消息的转发方式(路由规则),广播,组播,单播 



- java
  - 技术转件
    - 消息队列
    - 大规模分布式的部署
  - 架构
- cpp
  - 操作系统
  - 存储系统,缓存
  - 网络通信
  - 消息中间件



##### rabbitmq

老牌的消息队列产品(卡夫卡的出现替代了他)

- rabbitmq基于AMQP协议 advanced message queuing protocol
- 为了可靠性,牺牲了性能



AMQP的组件

- 交换器 Exchange 所有的消息经过exchange进行分发
- 队列 Queue 队列对应于每一个消费者,存取将要传递给消费者的数据
- 绑定 Binding 每一个队列和交换器的对应关系



![image-20220903193354720](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302230932575.png)



exchange的消息路由模式

routining key 路由键 - 根据key值选择一个合适的消息出口

![image-20220903194024806](https://test4projectwf.oss-cn-hangzhou.aliyuncs.com/image/202302230932666.png)

- direct模式 - 当routining key 和 binding key完全一致的时候进行传递
  - 实现了单播(可以通过 binding key 设置为相同来实现组播)
- fanout模式 - 交换器不做任何的检查 - 广播 - 性能更好 
- topic模式 - 通配符匹配 - 组播
- headers模式 - 在消息中设置首部字段 - 根据消息的内容进行分发 - 组播

后两者,通配符匹配和内容匹配的效率都不高,所以应用并不多



消息队列在网盘中的使用场景

- 发送给OSS进行备份的数据,先异步转移到消息队列中去(采用direct模式)

  

###### 使用docker来部署rabbitmq 

​	因为rabbitmq是通过erlang语言实现的产品,所以部署在c++的项目中需用docker

```
下载镜像
docker pull rabbitmq:management 
```



```
docker run -d --hostname rabbitserver --name rabbit
有三个端口
5672 - 提供了程序的api
15672 - http协议甚至是网页页面来管理rabbitmq
25672 - rabbit集群所用端口
-v 建立持久化的挂载目录
```

